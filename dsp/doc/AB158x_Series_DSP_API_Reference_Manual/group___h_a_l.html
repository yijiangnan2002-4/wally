<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AB158x Series DSP API Reference: HAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="airoha.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AB158x Series DSP API Reference
   &#160;<span id="projectnumber">Airoha IoT SDK for BT Audio</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___h_a_l.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">HAL</div>  </div>
</div><!--header-->
<div class="contents">

<p>This section introduces the HAL driver APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, HAL function groups, enums, structures and functions.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>This section introduces the HAL driver APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, HAL function groups, enums, structures and functions. </p>
<h1><a class="anchor" id="HAL_Overview_1_Chapter"></a>
Terms and acronyms</h1>
<table class="doxtable">
<tr>
<th>Acronyms </th><th>Definition  </th></tr>
<tr>
<td><b>EINT</b> </td><td>External interrupt </td></tr>
<tr>
<td><b>GDMA</b> </td><td>General direct memory access </td></tr>
<tr>
<td><b>GPIO</b> </td><td>General purpose Input Output </td></tr>
<tr>
<td><b>GPT</b> </td><td>General purpose timer </td></tr>
<tr>
<td><b>I2C</b> </td><td>Inter-integrated circuit </td></tr>
<tr>
<td><b>I2S</b> </td><td>Inter-integrated sound </td></tr>
<tr>
<td><b>MPU</b> </td><td>Memory protect unit </td></tr>
<tr>
<td><b>SPI</b> </td><td>Serial Peripheral Interface </td></tr>
<tr>
<td><b>UART</b> </td><td>Universal asynchronous receiver/transmitter </td></tr>
<tr>
<td><b>USB</b> </td><td>Universal Serial Bus </td></tr>
<tr>
<td><b>DCM</b> </td><td>Dynamic Clock Management </td></tr>
</table>
<h1><a class="anchor" id="HAL_Overview_2_Chapter"></a>
Overview of HAL drivers</h1>
<ul>
<li><b>Introduction</b> <br />
 Airoha SDK hardware abstraction layer (HAL) driver is embedded software ensuring maximized portability across IoT portfolio designed for Airoha IoT SDK development platform.<br />
 The HAL driver interface is common for DSP0 and DSP1, because DSP0 and DSP1 with same type of processor and share same peripheral hardware. The HAL driver includes:<br />
<ul>
<li>Drivers for the peripheral modules, such as UART and I2C;<br />
</li>
<li>Drivers for the system modules, such as CACHE, MPU and FLASH;<br />
</li>
<li>APIs of the modules.<br />
 The HAL driver has both standard and advanced features and is easy to use. It makes the upper hardware abstraction layer portable.<br />
 The HAL layer provides a generic set of APIs to interact with the upper layers, such as application, middleware and the OS. The APIs are defined interfaces for Airoha IoT portfolio, so the upper layer written with the HAL API is portable across the Airoha IoT platforms.<br />
 The HAL driver covers rich modules, including all peripheral modules, such as UART, I2C and SPI. It also includes number of system modules, such as CACHE, MPU, FLASH and DMA.<br />
 The HAL complies with the general naming convention and common coding style. Each module of the HAL has its distinctive folder structure along with supporting examples.</li>
</ul>
</li>
<li><b>HAL</b> <b>driver</b> <b>architecture</b> <br />
The HAL driver architecture is shown below:<br />
<div class="image">
<img src="hal_overview_driver_architecture.png" alt="hal_overview_driver_architecture.png"/>
</div>
</li>
<li><b>HAL</b> <b>folder</b> <b>structure</b> <b>and</b> <b>file</b> <b>inclusion</b> <b>model</b> <br />
<ul>
<li><b>HAL</b> <b>folder</b> <b>structure</b> <br />
 The HAL module folder structure is shown below: <div class="image">
<img src="hal_overview_folder_structure.png" alt="hal_overview_folder_structure.png"/>
</div>
<ul>
<li>Driver: All common driver files, such as board driver, HAL driver.<br />
</li>
<li>Driver/board: The driver files that are associated with the board, such as hw_resource_assignment or sct key.<br />
</li>
<li>Driver/chip/inc: The public header files of the HAL.<br />
</li>
<li>Driver/chip/mtxxxx: The driver files that are specific to the chipset, such as UART, I2C, GPT, PWM, WDT, etc.<br />
</li>
</ul>
</li>
<li><b>File</b> <b>inclusion</b> <b>model</b> <br />
<div class="image">
<img src="hal_overview_file_inclusion_model.png" alt="hal_overview_file_inclusion_model.png"/>
</div>
</li>
</ul>
</li>
<li><b>HAL</b> <b>driver</b> <b>rules</b> <br />
<ul>
<li><b>HAL</b> <b>file</b> <b>naming</b> <b>convention</b> <br />
 The HAL public header files are named as hal_{feature}.h(e.g., hal_adc.h.)<br />
 All HAL drivers are in driver/chip/mtxxxx/inc and driver/chip/mtxxxx/src, they are named as hal_{feature}.c or hal_{feature}_{sub_feature}.c, (e.g., hal_cache.c and hal_cache_internal.c)<br />
</li>
<li><b>HAL</b> <b>public</b> <b>API</b> <b>naming</b> <b>convention</b> <br />
<table class="doxtable">
<tr>
<th></th><th>naming convention  </th></tr>
<tr>
<td>function names </td><td>hal_{feature}_{sub_feature}(), such as <a class="el" href="group___n_v_i_c.html#gadda9d294f5812bbd756712053767151c" title="This function initializes the NVIC IRQ with default priority. ">hal_nvic_init()</a> </td></tr>
<tr>
<td>enum names </td><td>Type name:hal_{feature}_{sub_feature}_t, such as <a class="el" href="group__hal__nvic__enum.html#gab348d4200902666c0bfcd9ca075e0d60" title="This enum defines the return status of the NVIC API. ">hal_nvic_status_t</a>. <br />
 Enum member names:HAL_{FEATURE}_{SUB_FEATURE}, such as <a class="el" href="group__hal__nvic__enum.html#ggab348d4200902666c0bfcd9ca075e0d60abd1f73380e3e80a19ff13486c1b865be" title="No error occurred. ">HAL_NVIC_STATUS_OK</a>. </td></tr>
<tr>
<td>struct name </td><td>Type name:hal_{feature}_{sub_feature}_t,such as <a class="el" href="structhal__eint__config__t.html" title="This structure defines the initial configuration structure. ">hal_eint_config_t</a>.<br />
 Struct member names must be lowercase. </td></tr>
<tr>
<td>macro names </td><td>HAL_{FEATURE}_{SUB_FEATURE}, such as <a class="el" href="group__hal__nvic__macro.html#ga304d75660fc43bf61b3563812eb4913b" title="This macro is used to query the current exception status of DSP. ">HAL_NVIC_QUERY_EXCEPTION_NUMBER</a> </td></tr>
<tr>
<td>function pointer names </td><td>hal_{feature}_{sub_feature}_t(), such as void (*<a class="el" href="group__hal__nvic__typedef.html#gad0c42a5b42564767be2aad2d77412a70" title="This defines the callback function prototype. ">hal_nvic_isr_t</a>)().<br />
</td></tr>
</table>
</li>
</ul>
</li>
<li><b>HAL</b> <b>configuration</b> <br />
<ul>
<li><b>hal_feature_config.h</b> <br />
 Every project should include hal_feature_config.h for HAL configuration.<br />
 If certain HAL modules are not used, they can be removed from the feature options by undefining the macro, such as undefine the option of HAL_CACHE_MODULE_ENABLED.<br />
 For customized parameter settings.<br />
<br />
<br />
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="HAL_Overview_3_Chapter"></a>
HAL Driver Model</h1>
<p>Some drivers can operate in two modes: polling and interrupt. The UART HAL driver, for example, can operate in polling and interrupt modes during data communication. The polling mode is suitable for read and write operations of a small amount of data in low frequency. The interrupt mode is suitable for read and write operations of small amount of data in high frequency. In UART DMA mode, for example, an interrupt is triggered when the DMA is complete.</p><ul>
<li><b>Polling</b> <b>mode</b> <b>architecture</b> <br />
 Most of the driver modules support the polling mode, which is the basic feature in HAL.<br />
 For example, call the <a class="el" href="group___g_p_t.html#ga7eeb91d7f4e873d2f49fd79861c40e32" title="This function sets the delay time in milliseconds. ">hal_gpt_delay_ms()</a> API to apply a millisecond time delay in the GPT. The GPT HAL driver will poll the GPT hardware if the time delay is reached.<br />
 The polling mode driver architecture is shown below: <div class="image">
<img src="hal_overview_driver_polling_architecture.png" alt="hal_overview_driver_polling_architecture.png"/>
</div>
</li>
<li><p class="startli"><b>Interrupt</b> <b>mode</b> <b>architecture</b> <br />
 To improve the portability, the HAL driver hides the OS dependence by preventing the upper layer to call the OS level services directly. The HAL drivers uses an interrupt handler to provide the upper layer with a callback mechanism.</p>
<p class="startli">To use the interrupt handler of a driver module, a callback must be registered with the interrupt handler. When the interrupt occurs, the callback is invoked in Cortex-M4 handler mode. Call the <a class="el" href="group___g_p_t.html#gaf7b69551e5a5b473c269635bab034d99" title="This function starts the software timer. ">hal_gpt_sw_start_timer_ms()</a> API to start a timer. When the timer expires, the GPT hardware issues an interrupt. The GPT HAL driver then invokes the user callback in the interrupt handler to notify that the timer has expired. The interrupt mode driver architecture is shown in the following image: </p><div class="image">
<img src="hal_overview_interrupt_mode_architecture.png" alt="hal_overview_interrupt_mode_architecture.png"/>
</div>
<p class="startli">All HAL APIs are thread-safe and available for ISR. Developers can call HAL APIs in any FreeRTOS task or in an ISR.<br />
 However, some hardware has limited resources, and the corresponding APIs return an "ERROR_BUSY" status when there is a resource conflict due to the re-entrance. Developers should always check the return values from HAL APIs.<br />
</p>
</li>
</ul>
<h1><a class="anchor" id="HAL_Overview_4_Chapter"></a>
The Architecture Of DSP Platform</h1>
<p>"Processors have traditionally been extremely difficult to design and modify. Therefore, most systems contain rigid processors that were designed and verified once for general-purpose use and then embedded into multiple applications over time. Because these processors are general-purpose designs, their suitability to any particular application is less than ideal. Although it would be preferable to have a processor specifically designed to execute a particular application¡¯s code better (for example, to run faster, or consume less power, or cost less), this is rarely possible because of the difficulty; the time, cost, and risk of modifying an existing processor or developing a new processor is very high."-Reference from "Xtensa Instruction Set Architesture (ISA).pdf"<br />
 So we need to add some DSP processors to our platform. For example, On the platform of AB155x, we used the DSP of HiFi Mini designed by Xtensa.<br />
 On AB155x platform there are two DSP processors and share all of the external hardware resources including the bus system and peripherals. The architecture is shown below.<br />
 </p><div class="image">
<img src="hal_overview_dsp_platform_architecture.png" alt="hal_overview_dsp_platform_architecture.png"/>
</div>
<h1><a class="anchor" id="HAL_Overview_5_Chapter"></a>
The convention of cross core memory access</h1>
<p>Every core have its own sleep and DCM mechanism. <br />
 Because DSP0 I/DRAM and DSP1 I/DRAM locate in the core, if DSP0 or DSP1 enter sleep or enter DCM mode, other cores or DMA will can not access DSP0 and DSP1.<br />
 So if user want to do DSP I/DRAM memory access cross cores, need to do sleep lock for the target core. </p><div class="image">
<img src="hal_overview_cross_core_memory_access.png" alt="hal_overview_cross_core_memory_access.png"/>
</div>
<p> Note:<br />
</p><ol type="1">
<li>For customer and upper layer users, CM4 should not access DSP0 and DSP1 I/DRAM.</li>
<li>When user call <a class="el" href="group___s_l_e_e_p___m_a_n_a_g_e_r.html#gad02f0cc49c3fe9a1c29a1d31068a4c0e" title="This function prevents the MCU from getting into sleep mode. ">hal_sleep_manager_lock_sleep()</a> to do sleep lock cross cores, must guarantee the target core had been boot up. <br />
 Because the fucntion means the source core will send event via CCNI to the target core and wait for the target core lock sleep by itself done.<br />
 The pseudocode of CPU to do memory access cross cores: <div class="fragment"><div class="line"><span class="comment">//DSP0 want to access DSP1 DRAM:</span></div><div class="line"><a class="code" href="group___s_l_e_e_p___m_a_n_a_g_e_r.html#gad02f0cc49c3fe9a1c29a1d31068a4c0e">hal_sleep_manager_lock_sleep</a>(SLEEP_LOCK_DSP1_CROSS_MEMORY_ACCESS);</div><div class="line"><span class="comment">// please add your code of DSP0 access DSP1 DRAM to here!!!</span></div><div class="line"><a class="code" href="group___s_l_e_e_p___m_a_n_a_g_e_r.html#gaac8d09ef97a95c898ea1f55f9ca31197">hal_sleep_manager_unlock_sleep</a>(SLEEP_LOCK_DSP1_CROSS_MEMORY_ACCESS);</div></div><!-- fragment --> The pseudocode of DMA to do memory access cross cores: <div class="fragment"><div class="line"><span class="comment">//DSP0 start DMA to access DSP1 DRAM:</span></div><div class="line"><span class="comment">// User should lock DSP1 sleep before start DMA</span></div><div class="line"><span class="comment">// source_address or destination_address is DSP1 DRAM.</span></div><div class="line">     <a class="code" href="group__hal__sw__dma__enum.html#ga57abcb3c6e8078bf10f8ad83f14be6ff">hal_sw_gdma_status_t</a> status;</div><div class="line">     temp_dma_cfg.<a class="code" href="structhal__sw__dma__config__info__t.html#ac49207258d3fa0feebe6500bfec32a91">source_address</a> = source_address;</div><div class="line">     temp_dma_cfg.<a class="code" href="structhal__sw__dma__config__info__t.html#a27c9c2de11edf0bec40616419f87487c">destination_address</a> = destination_address;</div><div class="line">     temp_dma_cfg.<a class="code" href="structhal__sw__dma__config__info__t.html#aebb70c2aab3407a9f05334c47131a43b">length</a> = dma_length;</div><div class="line">     temp_dma_cfg.<a class="code" href="structhal__sw__dma__config__info__t.html#a085ff329d2c848adbbb2acc37fe29a8b">func</a> = user_dma_transfer_done_callback;</div><div class="line">     temp_dma_cfg.<a class="code" href="structhal__sw__dma__config__info__t.html#a6a0147ed63ef3f0f7e291aa5f6f48191">argument</a> = NULL;</div><div class="line">     temp_dma_cfg.<a class="code" href="structhal__sw__dma__config__info__t.html#ac72a269230d386b4b8ada7e3efc4e6bd">h_size</a> = <a class="code" href="group__hal__sw__dma__enum.html#ggafe601919a6b2b4f008ab7660a3e51a80a28a055441c592fa975d8ece7e0ea8b1b">HAL_SW_DMA_WORD</a>;</div><div class="line">     temp_dma_cfg.<a class="code" href="structhal__sw__dma__config__info__t.html#ae3d5ec8df47acc37c1b3ca8ab0281ea9">dma_type</a> = <a class="code" href="group__hal__sw__dma__enum.html#ggaec90e2396e4a93f27bdfbfa6a04b931aa1fd91726ef5aaf69b373cf6738aefce2">HAL_SW_DMA_NORMAL_MODE</a>;</div><div class="line">     <a class="code" href="group___s_l_e_e_p___m_a_n_a_g_e_r.html#gad02f0cc49c3fe9a1c29a1d31068a4c0e">hal_sleep_manager_lock_sleep</a>(SLEEP_LOCK_DSP1_CROSS_MEMORY_ACCESS);</div><div class="line">     status = <a class="code" href="group___s_w___d_m_a.html#gace3bcd8b28323857f6a5e9bc16048b17">hal_sw_gdma_start</a>(&amp;temp_dma_cfg);</div><div class="line">     <span class="keywordflow">if</span> (status != <a class="code" href="group__hal__sw__dma__enum.html#gga57abcb3c6e8078bf10f8ad83f14be6ffac90a384ef6616f02ae6cf3c7280a2404">HAL_SW_DMA_STATUS_OK</a>) {</div><div class="line">         <span class="comment">// Error handling.</span></div><div class="line">     }</div><div class="line"></div><div class="line"><span class="comment">// this function is the DMA callback, user should do DSP1 sleep unlock after DMA copy done.</span></div><div class="line">    <span class="keywordtype">void</span> user_dma_transfer_done_callback()</div><div class="line">    {</div><div class="line">        <span class="comment">// now DMA copy done!!!</span></div><div class="line">        <a class="code" href="group___s_l_e_e_p___m_a_n_a_g_e_r.html#gaac8d09ef97a95c898ea1f55f9ca31197">hal_sleep_manager_unlock_sleep</a>(SLEEP_LOCK_DSP1_CROSS_MEMORY_ACCESS);</div><div class="line">    }</div></div><!-- fragment --> </li>
</ol>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___c_a_c_h_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_c_h_e.html">CACHE</a></td></tr>
<tr class="memdesc:group___c_a_c_h_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section describes the programming interfaces of the CACHE controller. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_c_n_i"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_n_i.html">CCNI</a></td></tr>
<tr class="memdesc:group___c_c_n_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the Cross Core Notification Interface(CCNI) HAL APIs including terms and acronyms, details on how to use this driver, supported features, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_l_o_c_k"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k.html">CLOCK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___d_w_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_w_t.html">DWT</a></td></tr>
<tr class="memdesc:group___d_w_t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the DSP Debug Watchpoint and Trace(DWT) APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___e_i_n_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_i_n_t.html">EINT</a></td></tr>
<tr class="memdesc:group___e_i_n_t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the External Interrupt Controller(EINT) APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, EINT function groups, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___g_p_i_o"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_i_o.html">GPIO</a></td></tr>
<tr class="memdesc:group___g_p_i_o"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section provides introduction to the General Purpose Input Output (GPIO) APIs, including terms and acronyms, features, architecture, how to use APIs, the GPIO function groups, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___g_p_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html">GPT</a></td></tr>
<tr class="memdesc:group___g_p_t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the General Purpose Timer(GPT) driver APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, GPT function groups, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___h_w___s_e_m_a_p_h_o_r_e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_w___s_e_m_a_p_h_o_r_e.html">HW_SEMAPHORE</a></td></tr>
<tr class="memdesc:group___h_w___s_e_m_a_p_h_o_r_e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section describes the programming interfaces of the SEMAPHORE HAL driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___i2_c___m_a_s_t_e_r"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___m_a_s_t_e_r.html">I2C_MASTER</a></td></tr>
<tr class="memdesc:group___i2_c___m_a_s_t_e_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section describes the programming interfaces of the Inter-Integrated Circuit Master(I2C_MASTER) driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___i2_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html">I2S</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___n_v_i_c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_i_c.html">NVIC</a></td></tr>
<tr class="memdesc:group___n_v_i_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the Nested Vectored Interrupt Controller(NVIC) HAL APIs including terms and acronyms, details on how to use this driver, supported features, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___s_l_e_e_p___m_a_n_a_g_e_r"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_l_e_e_p___m_a_n_a_g_e_r.html">SLEEP_MANAGER</a></td></tr>
<tr class="memdesc:group___s_l_e_e_p___m_a_n_a_g_e_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the Sleep Manager driver APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, Sleep Manager function groups, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___s_p_i___m_a_s_t_e_r"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___m_a_s_t_e_r.html">SPI_MASTER</a></td></tr>
<tr class="memdesc:group___s_p_i___m_a_s_t_e_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the Serial Peripheral Interface Master (SPI_Master) APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___s_w___d_m_a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_w___d_m_a.html">SW_DMA</a></td></tr>
<tr class="memdesc:group___s_w___d_m_a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the Software General Direct Memeory Access(SW_DMA) APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, SW_DMA function groups, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___t_r_n_g"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_n_g.html">TRNG</a></td></tr>
<tr class="memdesc:group___t_r_n_g"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the True Randam Number Generator(TRNG) APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, TRNG function groups, enums, structures and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___u_a_r_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html">UART</a></td></tr>
<tr class="memdesc:group___u_a_r_t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This section introduces the Universal Asynchronous Receiver/Transmitter (UART) enums and structures. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 28 2023 17:13:49 for AB158x Series DSP API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
