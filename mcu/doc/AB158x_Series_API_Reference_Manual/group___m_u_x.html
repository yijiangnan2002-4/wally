<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AB158x Series MCU API Reference: MUX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="airoha.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AB158x Series MCU API Reference
   &#160;<span id="projectnumber">Airoha IoT SDK for BT Audio</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___m_u_x.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">MUX<div class="ingroups"><a class="el" href="group__kernel__service.html">Kernel_service</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This section introduces the MUX APIs including terms and acronyms, supported features, details on how to use MUX, function groups, enums, structures, and functions.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>This section introduces the MUX APIs including terms and acronyms, supported features, details on how to use MUX, function groups, enums, structures, and functions. </p>
<p>MUX is a multiplexer for some communication devices, like: USB/UART/SPI slave/I2C slave etc.</p>
<h1><a class="anchor" id="MUX_Terms_Chapter"></a>
Terms and acronyms</h1>
<table class="doxtable">
<tr>
<th>Terms </th><th>Details  </th></tr>
<tr>
<td><b>MUX</b> </td><td>Multiplexer </td></tr>
<tr>
<td><b>Virtual</b> <b>Register</b> </td><td>Interface for SPI and I2C slave </td></tr>
<tr>
<td><b>NVDM</b> </td><td>Non-volatile Data Management </td></tr>
<tr>
<td><b>UART</b> </td><td>Universal Asynchronous Receiver/Transmitter </td></tr>
<tr>
<td><b>USB</b> </td><td>Universal Serial Bus </td></tr>
</table>
<h1><a class="anchor" id="MUX_Architecture"></a>
Architecture</h1>
<div class="image">
<img src="mux_sw_architecture_overview.png" alt="mux_sw_architecture_overview.png"/>
</div>
 <h1><a class="anchor" id="MUX_Features_Chapter"></a>
Supported features</h1>
<ul>
<li><b>Ports</b> <b>management</b> <ul>
<li>The MUX module manages a lot of device ports to do port assignment.</li>
</ul>
</li>
<li><b>Data</b> <b>communication</b> <ul>
<li>The MUX module use various device ports to send and receive data.</li>
</ul>
</li>
<li><b>Support</b> <b>multiple</b> <b>users</b> <b>on</b> <b>one</b> <b>MUX</b> <b>channel</b>.<ul>
<li>Some user with same data package format can MUX together to use one MUX port.</li>
</ul>
</li>
<li><b>High</b> <b>performance</b> <ul>
<li>Just one time memory copy when MUX send data.</li>
</ul>
</li>
<li><b>Less</b> <b>resources</b> <b>requirement</b> <ul>
<li>No need task to do MUX send and receive data.</li>
<li>Use read point and write point to manage the ring buffer. <div class="image">
<img src="mux_rx_tx_ring_buffer.png" alt="mux_rx_tx_ring_buffer.png"/>
</div>
 </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="MUX_HOWTO"></a>
How to use MUX Module</h1>
<ul>
<li><b>How</b> <b>to</b> <b>use</b> <b>MUX</b> <b>module</b> <ul>
<li>UART as sample: <div class="fragment"><div class="line"><a class="code" href="structmux__protocol__t.html">mux_protocol_t</a> mux_uart1_op;</div><div class="line"><a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> uart1_user1_handle,uart1_user2_handle;</div><div class="line"><a class="code" href="structmux__port__setting__t.html">mux_port_setting_t</a> setting;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a851ed1e9fa8b7874990afde3a9f0a9f8">tx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a2540bc9a02b6dfb6fe58a8496c58afbb">rx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.baudrate = <a class="code" href="group__hal__uart__enum.html#gga1d355134e173ec633b83dac1d65f35bba6110ff860b4f72503f6b6eeec8c3747b">HAL_UART_BAUDRATE_921600</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.word_length = <a class="code" href="group__hal__uart__enum.html#gga8370d3d1b9131c4f9711a3aa721db4feaa621725ad269aa90db8b7a28d1b83c7f">HAL_UART_WORD_LENGTH_8</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.stop_bit = <a class="code" href="group__hal__uart__enum.html#ggab0dbffa988302e67de658bc96daf7026ab9671de5a814169837c84c50f7c6e787">HAL_UART_STOP_BIT_1</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.parity = <a class="code" href="group__hal__uart__enum.html#gga67ed44b4958988acbd6cbccbe7d83b60a04bc6026ce33740e3290bf2489a1ab66">HAL_UART_PARITY_NONE</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.flowcontrol_type = <a class="code" href="group__mux__enum.html#gga3443aa283b9ff2ab0e48e138d32803e8afdc91cbd7bb006f9bb119c0d6ac493b7">MUX_UART_SW_FLOWCONTROL</a>;</div><div class="line"> mux_uart1_op.<a class="code" href="structmux__protocol__t.html#a16eccf62ffcc197478c751d691d11179">tx_protocol_callback</a> = mux_uart1_package_protocol_cb_for_tx;</div><div class="line"> mux_uart1_op.<a class="code" href="structmux__protocol__t.html#a8e2f6bae85243438e6285953b3622178">rx_protocol_callback</a> = mux_uart1_unpackage_protocol_cb_for_rx;</div><div class="line"></div><div class="line"> status = <a class="code" href="group___m_u_x.html#gaa5a6637a907492337e5ba1584e8566ac">mux_init</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>,&amp;setting,&amp;mux_uart1_op);</div><div class="line"> <span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">     assert(0);</div><div class="line"> status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>,<span class="stringliteral">&quot;uart1_user1&quot;</span>,&amp;uart1_user1_handle,uart1_mux_user1_cb,NULL);</div><div class="line"> <span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">     assert(0);</div><div class="line"> printf(<span class="stringliteral">&quot;uart1 user1 open done~~~handle:0x%x\r\n&quot;</span>,uart1_user1_handle);</div><div class="line"></div><div class="line"> status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>,<span class="stringliteral">&quot;uart1_user2&quot;</span>,&amp;uart1_user2_handle,uart1_mux_user2_cb,NULL);</div><div class="line"> <span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">     assert(0);</div><div class="line"> printf(<span class="stringliteral">&quot;uart1 user2 open done~~~handle:0x%x\r\n&quot;</span>,uart1_user2_handle);</div></div><!-- fragment --></li>
<li>USB as sample: <div class="fragment"><div class="line"><a class="code" href="structmux__protocol__t.html">mux_protocol_t</a> mux_usb2_op;</div><div class="line"><a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> usb2_user1_handle,usb2_user2_handle;</div><div class="line"><a class="code" href="structmux__port__setting__t.html">mux_port_setting_t</a> setting;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a851ed1e9fa8b7874990afde3a9f0a9f8">tx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a2540bc9a02b6dfb6fe58a8496c58afbb">rx_buffer_size</a> = 1024;</div><div class="line">mux_usb2_op.<a class="code" href="structmux__protocol__t.html#a16eccf62ffcc197478c751d691d11179">tx_protocol_callback</a> = NULL;</div><div class="line">mux_usb2_op.<a class="code" href="structmux__protocol__t.html#a8e2f6bae85243438e6285953b3622178">rx_protocol_callback</a> = mux_usb2_unpackage;</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gaa5a6637a907492337e5ba1584e8566ac">mux_init</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327abb3aacdd4be1e24690ddf93bdbdfb4a2">MUX_USB_COM_2</a>,&amp;setting,&amp;mux_usb2_op);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line"> assert(0);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327abb3aacdd4be1e24690ddf93bdbdfb4a2">MUX_USB_COM_2</a>,<span class="stringliteral">&quot;usb2_user1&quot;</span>,&amp;usb2_user1_handle,usb2_mux_user1_cb,NULL);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line"> assert(0);</div><div class="line">printf(<span class="stringliteral">&quot;USB2 user1 open done~~~handle:0x%x\r\n&quot;</span>,usb2_user1_handle);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327abb3aacdd4be1e24690ddf93bdbdfb4a2">MUX_USB_COM_2</a>,<span class="stringliteral">&quot;usb2_user2&quot;</span>,&amp;usb2_user2_handle,usb2_mux_user2_cb,NULL);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line"> assert(0);</div><div class="line">printf(<span class="stringliteral">&quot;USB2 user2 open done~~~handle:0x%x\r\n&quot;</span>,usb2_user2_handle);</div></div><!-- fragment --></li>
<li>SPI slave as sample: <div class="fragment"><div class="line"><a class="code" href="structmux__protocol__t.html">mux_protocol_t</a> mux_spi_slave_op;</div><div class="line"><a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> spi_slave_user1_handle,spi_slave_user2_handle;</div><div class="line"><a class="code" href="structmux__port__setting__t.html">mux_port_setting_t</a> setting;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a851ed1e9fa8b7874990afde3a9f0a9f8">tx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a2540bc9a02b6dfb6fe58a8496c58afbb">rx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.spi_slave.slave_config.bit_order = <a class="code" href="group__hal__spi__slave__enum.html#gga0acb328cc34aef8b1f2216aa45790f7fa6b403b1be66d4c0af04ce132b48c7102">HAL_SPI_SLAVE_LSB_FIRST</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.spi_slave.slave_config.phase = <a class="code" href="group__hal__spi__slave__enum.html#gga34434dca1239d3d67933d3c44d50ea81a6610f1f8b0059fc6ba6838ed8dc708df">HAL_SPI_SLAVE_CLOCK_PHASE0</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.spi_slave.slave_config.polarity = <a class="code" href="group__hal__spi__slave__enum.html#gga8c4d9cf35bae2e860a899a7ef2fb3846a2cc9b475bf12d5cfae1e2da6ad1cbf41">HAL_SPI_SLAVE_CLOCK_POLARITY0</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.spi_slave.slave_config.timeout_threshold = 0xffffffff;</div><div class="line"><span class="comment">//setting.dev_setting.spi_slave.early_miso = HAL_SPI_SLAVE_EARLY_MISO_DISABLE;</span></div><div class="line"></div><div class="line">mux_spi_slave_op.<a class="code" href="structmux__protocol__t.html#a16eccf62ffcc197478c751d691d11179">tx_protocol_callback</a> = NULL;</div><div class="line">mux_spi_slave_op.<a class="code" href="structmux__protocol__t.html#a8e2f6bae85243438e6285953b3622178">rx_protocol_callback</a> = mux_spi_slave_unpackage;</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gaa5a6637a907492337e5ba1584e8566ac">mux_init</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ace3d4715287fd3bdd1e4e1eafb3ac6a2">MUX_SPI_SLAVE_0</a>,&amp;setting,&amp;mux_spi_slave_op);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ace3d4715287fd3bdd1e4e1eafb3ac6a2">MUX_SPI_SLAVE_0</a>,<span class="stringliteral">&quot;spi_slave_user1&quot;</span>,&amp;spi_slave_user1_handle,spi_slave_mux_user1_cb,NULL);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line">printf(<span class="stringliteral">&quot;spi_slave user1 open done~~~handle:0x%x\r\n&quot;</span>,spi_slave_user1_handle);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ace3d4715287fd3bdd1e4e1eafb3ac6a2">MUX_SPI_SLAVE_0</a>,<span class="stringliteral">&quot;spi_slave_user2&quot;</span>,&amp;spi_slave_user2_handle,spi_slave_mux_user2_cb,NULL);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line">printf(<span class="stringliteral">&quot;spi_slave user2 open done~~~handle:0x%x\r\n&quot;</span>,spi_slave_user2_handle);</div></div><!-- fragment --></li>
<li>I2C slave as sample: <div class="fragment"><div class="line"><span class="preprocessor">#define DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW 0x50</span></div><div class="line"><span class="preprocessor">#define DEMO_I2C_SLAVE_ADDRESS_R        0x54</span></div><div class="line"><span class="preprocessor">#define DEMO_I2C_SLAVE_ADDRESS_W        0x58</span></div><div class="line"><a class="code" href="structmux__protocol__t.html">mux_protocol_t</a> mux_i2c_slave_op;</div><div class="line"><a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> i2c_slave_user1_handle,i2c_slave_user2_handle;</div><div class="line"><a class="code" href="structmux__port__setting__t.html">mux_port_setting_t</a> setting;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a851ed1e9fa8b7874990afde3a9f0a9f8">tx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a2540bc9a02b6dfb6fe58a8496c58afbb">rx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.i2c_slave.cr_or_cw_slave_address = DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.i2c_slave.r_slave_address = DEMO_I2C_SLAVE_ADDRESS_R;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.i2c_slave.w_slave_address = DEMO_I2C_SLAVE_ADDRESS_W;</div><div class="line">mux_i2c_slave_op.<a class="code" href="structmux__protocol__t.html#a16eccf62ffcc197478c751d691d11179">tx_protocol_callback</a> = NULL;</div><div class="line">mux_i2c_slave_op.<a class="code" href="structmux__protocol__t.html#a8e2f6bae85243438e6285953b3622178">rx_protocol_callback</a> = mux_i2c_slave_unpackage;</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gaa5a6637a907492337e5ba1584e8566ac">mux_init</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327a138c17922fe30e4142e94948ce702887">MUX_I2C_SLAVE_0</a>,&amp;setting,&amp;mux_i2c_slave_op);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327a138c17922fe30e4142e94948ce702887">MUX_I2C_SLAVE_0</a>,<span class="stringliteral">&quot;i2c_slave_user1&quot;</span>,&amp;i2c_slave_user1_handle,i2c_slave_mux_user1_cb,NULL);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line">printf(<span class="stringliteral">&quot;i2c_slave user1 open done~~~handle:0x%x\r\n&quot;</span>,i2c_slave_user1_handle);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327a138c17922fe30e4142e94948ce702887">MUX_I2C_SLAVE_0</a>,<span class="stringliteral">&quot;i2c_slave_user2&quot;</span>,&amp;i2c_slave_user2_handle,i2c_slave_mux_user2_cb,NULL);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line">printf(<span class="stringliteral">&quot;i2c_slave user2 open done~~~handle:0x%x\r\n&quot;</span>,i2c_slave_user2_handle);</div></div><!-- fragment --></li>
</ul>
</li>
<li><b>How</b> <b>to</b> <b>implement</b> <b>Rx</b> <b>and</b> <b>Tx</b> <b>protocol_callback</b> <ul>
<li><b>About</b> <b>tx_protocol_callback</b> <br />
 When the user owns a mux channel, means maybe no need add package header, then the parameter of tx_protocol_callback should be NULL.<br />
 When multiple users want to share a mux channel, means need add package header, then the parameter of tx_protocol_callback should implement by user.<br />
 For example: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> mux_uart1_package_protocol_cb_for_tx(<a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle, <span class="keyword">const</span> <a class="code" href="structmux__buffer__t.html">mux_buffer_t</a> payload[],uint32_t buffers_counter, <a class="code" href="structmux__buffer__t.html">mux_buffer_t</a> *head, <a class="code" href="structmux__buffer__t.html">mux_buffer_t</a> *tail,<span class="keywordtype">void</span> *user_data)</div><div class="line"> {</div><div class="line">     <span class="comment">//step1:Analysis the handle to identify which one user.</span></div><div class="line">            user_id = analysis_handle(handle);</div><div class="line">    <span class="comment">//step2: Calculate the payload size.</span></div><div class="line">            size = calculate_size(payload,buffers_counter);</div><div class="line">    <span class="comment">//step3:prepare the header buffer if need.</span></div><div class="line">            <span class="comment">//prepare header buffer</span></div><div class="line">            <span class="comment">//User must pay attention to the buffer copy length and make sure that it does not exceed TX_PROTOCOL_CB_HEAD_BUFFER_MAX_LEN</span></div><div class="line">            head-&gt;<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>[0] = 0x11;</div><div class="line">            head-&gt;<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>[1] = 0x22;</div><div class="line">            <span class="comment">//....</span></div><div class="line">            head-&gt;<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>[N] = 0xnn;</div><div class="line">            <span class="comment">//User must pay attention to N must be less than TX_PROTOCOL_CB_HEAD_BUFFER_MAX_LEN</span></div><div class="line">            head-&gt;<a class="code" href="structmux__buffer__t.html#a50820ebe716191dad920c497510b3220">buf_size</a> = N;</div><div class="line">   <span class="comment">//step4:prepare the tail buffer if need.</span></div><div class="line">            <span class="comment">//User must pay attention to the buffer copy length and make sure that it does not exceed TX_PROTOCOL_CB_TAIL_BUFFER_MAX_LEN</span></div><div class="line">            tail-&gt;<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>[0] = 0x11;</div><div class="line">            tail-&gt;<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>[1] = 0x22;</div><div class="line">            <span class="comment">//....</span></div><div class="line">            tail-&gt;<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>[M] = 0xnn;</div><div class="line">            <span class="comment">//User must pay attention to M must be less than TX_PROTOCOL_CB_TAIL_BUFFER_MAX_LEN</span></div><div class="line">            tail-&gt;<a class="code" href="structmux__buffer__t.html#a50820ebe716191dad920c497510b3220">buf_size</a> = M;</div><div class="line">}</div></div><!-- fragment --></li>
<li><b>About</b> <b>rx_protocol_callback</b> <br />
 When the user owns a mux channel, means maybe no need add package tail, then the parameter of rx_protocol_callback should be NULL.<br />
 When multiple users want to share a mux channel, user decide whether need tail in the package or not. if need, the parameter of tx_protocol_callback should implement by user.<br />
 For example: <div class="fragment"><div class="line"><span class="keywordtype">void</span> mux_uart1_unpackage_protocol_cb_for_rx(<a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> *handle, <a class="code" href="structmux__buffer__t.html">mux_buffer_t</a> buffers[],uint32_t buffers_counter,</div><div class="line">               uint32_t *consume_len, uint32_t *package_len,<span class="keywordtype">void</span> *user_data)</div><div class="line">{</div><div class="line">   <span class="comment">//step1:Analysis the handle to identify which one user.</span></div><div class="line">          user_id = analysis_handle(handle);</div><div class="line">   <span class="comment">//Step2:analysis data to find the abandon data in front, user should pay attention that the consume_len data will be abandoned.</span></div><div class="line">       *consume_len = analysis_data_to_find_consume_len(buffers,buffers_counter);</div><div class="line">   <span class="comment">//Step3:analysis data to find first full package in front, if not find, please set *package_len to 0x0, means the data not enough, mux driver will call the callback again when receive more data.</span></div><div class="line">       *package_len = analysis_data_to_find_consume_len(buffers,buffers_counter);</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
</li>
<li><b>How</b> <b>to</b> <b>send</b> <b>data</b> <ul>
<li>Send one buffer one time: <div class="fragment"><div class="line">uint32_t return_value;</div><div class="line"><a class="code" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> status;</div><div class="line"><a class="code" href="structmux__buffer__t.html">mux_buffer_t</a> temp_buff;</div><div class="line">temp_buff.<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>  = <span class="stringliteral">&quot;This is UART1 user1 Tx~~~\r\n&quot;</span>;</div><div class="line">temp_buff.<a class="code" href="structmux__buffer__t.html#a50820ebe716191dad920c497510b3220">buf_size</a> = strlen(temp_buff.<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>);</div><div class="line"><a class="code" href="group___m_u_x.html#ga48d5fd6803eeb99dd52d990cd7c7748f">mux_tx</a>(uart1_user1_handle,&amp;temp_buff,1,&amp;return_value);</div></div><!-- fragment --></li>
<li>Send multi buffers one time: <div class="fragment"><div class="line">uint32_t return_value;</div><div class="line"><a class="code" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> status;</div><div class="line"><a class="code" href="structmux__buffer__t.html">mux_buffer_t</a> temp_buff[3];</div><div class="line">temp_buff[0].<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>  = <span class="stringliteral">&quot;This is UART1 user1 Tx~~~ one\r\n&quot;</span>;</div><div class="line">temp_buff[0].<a class="code" href="structmux__buffer__t.html#a50820ebe716191dad920c497510b3220">buf_size</a> = strlen(temp_buff[0].p_buf);</div><div class="line">temp_buff[1].<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>  = <span class="stringliteral">&quot;This is UART1 user1 Tx~~~ two\r\n&quot;</span>;</div><div class="line">temp_buff[1].<a class="code" href="structmux__buffer__t.html#a50820ebe716191dad920c497510b3220">buf_size</a> = strlen(temp_buff[1].p_buf);</div><div class="line">temp_buff[2].<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a>  = <span class="stringliteral">&quot;This is UART1 user1 Tx~~~ three\r\n&quot;</span>;</div><div class="line">temp_buff[2].<a class="code" href="structmux__buffer__t.html#a50820ebe716191dad920c497510b3220">buf_size</a> = strlen(temp_buff[2].p_buf);</div><div class="line"><a class="code" href="group___m_u_x.html#ga48d5fd6803eeb99dd52d990cd7c7748f">mux_tx</a>(uart1_user1_handle,&amp;temp_buff,3,&amp;return_value);</div></div><!-- fragment --></li>
</ul>
</li>
<li><b>How</b> <b>to</b> <b>receive</b> <b>data</b> <ul>
<li>UART as sample: <div class="fragment"><div class="line"><span class="keywordtype">void</span> uart1_mux_user1_cb(<a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle, <a class="code" href="group__mux__enum.html#ga9870a3394b4f72cec5cd8d7ecc52368c">mux_event_t</a> event,uint32_t data_len,<span class="keywordtype">void</span>*user_data)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga9870a3394b4f72cec5cd8d7ecc52368cabb2bae1935b5124cf06980b3cd95a83a">MUX_EVENT_READY_TO_READ</a> == event)</div><div class="line">    {</div><div class="line">        printf(<span class="stringliteral">&quot;this is uart1 user1 MUX_EVENT_READY_TO_READ&quot;</span>);</div><div class="line">        <span class="comment">// User also can just send a message to task on here, and call mux_rx() to get data on task thread.</span></div><div class="line">        {</div><div class="line">            <span class="keywordtype">char</span> *temp_buff[100];</div><div class="line">            <a class="code" href="structmux__buffer__t.html">mux_buffer_t</a> buffer;</div><div class="line">            buffer.<a class="code" href="structmux__buffer__t.html#a50820ebe716191dad920c497510b3220">buf_size</a> = 100;</div><div class="line">            buffer.<a class="code" href="structmux__buffer__t.html#afeaeee72b488745390daf8d4716e63ea">p_buf</a> = temp_buff;</div><div class="line">            uint32_t len;</div><div class="line">            <a class="code" href="group___m_u_x.html#ga5aab70691132af097f69a6fca720d1e8">mux_rx</a>(uart1_user1_handle, &amp;buffer,&amp;len);</div><div class="line">            printf(<span class="stringliteral">&quot;vMuxTest_UART1_user1_Rx, get @@@@%d data\r\n&quot;</span>,len);</div><div class="line">       }</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga9870a3394b4f72cec5cd8d7ecc52368cac2f983870522ccb0aee7ace879475db6">MUX_EVENT_READY_TO_WRITE</a> == event)</div><div class="line">        printf(<span class="stringliteral">&quot;this is uart1 user1 MUX_EVENT_READY_TO_WRITE&quot;</span>);</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
</li>
<li><b>How</b> <b>to</b> <b>get</b> <b>and</b> <br />
 save <b>MUX</b> <b>port</b> <b>setting</b> <b>from</b> <b>NVDM</b> <ul>
<li>Take UART as sample: <div class="fragment"><div class="line"><a class="code" href="structmux__protocol__t.html">mux_protocol_t</a> mux_uart1_op;</div><div class="line"><a class="code" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> uart1_user1_handle,uart1_user2_handle;</div><div class="line"><a class="code" href="structmux__port__setting__t.html">mux_port_setting_t</a> setting;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a851ed1e9fa8b7874990afde3a9f0a9f8">tx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a2540bc9a02b6dfb6fe58a8496c58afbb">rx_buffer_size</a> = 1024;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.baudrate = <a class="code" href="group__hal__uart__enum.html#gga1d355134e173ec633b83dac1d65f35bba6110ff860b4f72503f6b6eeec8c3747b">HAL_UART_BAUDRATE_921600</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.word_length = <a class="code" href="group__hal__uart__enum.html#gga8370d3d1b9131c4f9711a3aa721db4feaa621725ad269aa90db8b7a28d1b83c7f">HAL_UART_WORD_LENGTH_8</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.stop_bit = <a class="code" href="group__hal__uart__enum.html#ggab0dbffa988302e67de658bc96daf7026ab9671de5a814169837c84c50f7c6e787">HAL_UART_STOP_BIT_1</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.uart_config.parity = <a class="code" href="group__hal__uart__enum.html#gga67ed44b4958988acbd6cbccbe7d83b60a04bc6026ce33740e3290bf2489a1ab66">HAL_UART_PARITY_NONE</a>;</div><div class="line">setting.<a class="code" href="structmux__port__setting__t.html#a1e4f700f609ecf51b7be93de6783ec69">dev_setting</a>.uart.flowcontrol_type = <a class="code" href="group__mux__enum.html#gga3443aa283b9ff2ab0e48e138d32803e8afdc91cbd7bb006f9bb119c0d6ac493b7">MUX_UART_SW_FLOWCONTROL</a>;</div><div class="line">mux_uart1_op.<a class="code" href="structmux__protocol__t.html#a16eccf62ffcc197478c751d691d11179">tx_protocol_callback</a> = mux_uart1_package_protocol_cb_for_tx;</div><div class="line">mux_uart1_op.<a class="code" href="structmux__protocol__t.html#a8e2f6bae85243438e6285953b3622178">rx_protocol_callback</a> = mux_uart1_unpackage_protocol_cb_for_rx;</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gaa5a6637a907492337e5ba1584e8566ac">mux_init</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>,&amp;setting,&amp;mux_uart1_op);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#ga432d4a2af6da3521e30c213e23dba123">mux_save_port_setting_to_nvdm</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>, &amp;setting);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>,<span class="stringliteral">&quot;uart1_user1&quot;</span>,&amp;uart1_user1_handle,uart1_mux_user1_cb,NULL);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line"></div><div class="line">status = <a class="code" href="group___m_u_x.html#ga97c1ceff149c0869c1a55cca75f0bb8a">mux_open_save_to_nvdm</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>, <span class="stringliteral">&quot;uart1_user1&quot;</span>);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    assert(0);</div><div class="line"></div><div class="line"><span class="comment">//the user had opened port</span></div><div class="line"><a class="code" href="structmux__port__buffer__t.html">mux_port_buffer_t</a> buffer;</div><div class="line"><span class="comment">//query which port that uart1_user1 had opened</span></div><div class="line">status = <a class="code" href="group___m_u_x.html#ga1a132be0e40aaa0ee999c2062370e965">mux_query_port_numbers_from_nvdm</a>(<span class="stringliteral">&quot;uart1_user1&quot;</span>, &amp;buffer);</div><div class="line"><span class="keywordflow">if</span> (status != <a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a>)</div><div class="line">    assert(0);</div><div class="line"><span class="comment">//can get the porting setting when got uart1_user1 used port</span></div><div class="line">status = <a class="code" href="group___m_u_x.html#ga86c22327683324a74928be3b2119aabb">mux_query_port_setting_from_nvdm</a>(buffer.<a class="code" href="structmux__port__buffer__t.html#ac7917f5599f3e52a22f93cadeac476bf">buf</a>[0], &amp;setting);</div><div class="line"><span class="keywordflow">if</span> (status != <a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a>)</div><div class="line">    assert(0);</div><div class="line"></div><div class="line"><span class="comment">//delete user from NVDM</span></div><div class="line">status = <a class="code" href="group___m_u_x.html#gab96848a9fcc7b346fb9d2dbd2f6d50c3">mux_close_delete_from_nvdm</a>(<a class="code" href="group__mux__enum.html#ggae1b0dd20d4db55a9ff0dc55ce93f6327ab963805086b4b339719b701de290e4da">MUX_UART_1</a>, <span class="stringliteral">&quot;uart1_user1&quot;</span>);</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="group__mux__enum.html#gga28ca7d6bdea64e62f33e874641a230a0a47d62a9154510555d9875c57c6da915c">MUX_STATUS_OK</a> != status)</div><div class="line">    <span class="keywordflow">return</span> status;</div></div><!-- fragment --> </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="MUX_MASTER_HOWTO"></a>
Mux support multiple devices</h1>
<ul>
<li><b>MUX</b> <b>support</b> <b>UART</b> <b>and</b> <b>USB</b> <br />
 UART and USB are basic modules for data communication. Those serial devices are easy to use by mux_rx and mux_rx to do data communication.<br />
</li>
<li><b>MUX</b> <b>support</b> <b>SPI</b> <b>slave</b> <br />
 The architecture of MUX SPI slave as below: <div class="image">
<img src="mux_spi_slave_architecture.png" alt="mux_spi_slave_architecture.png"/>
</div>
</li>
<li><b>MUX</b> <b>support</b> <b>I2C</b> <b>slave</b> <br />
 The architecture of MUX I2C slave as below: <div class="image">
<img src="mux_i2c_slave_architecture.png" alt="mux_i2c_slave_architecture.png"/>
</div>
 </li>
</ul>
<h1><a class="anchor" id="MUX_MASTER_DEMO"></a>
The demo code of host chip</h1>
<p>Airoha SDK provide the service of MUX to support SPI slave and I2C slave. Because of only SPI master and I2C master can start a data transmission, we must make some conventions between master and slave. For example, Master need query Slave Tx data length, then start a transmission to receive the data on master slide.</p><ul>
<li><b>Master</b> <b>demo</b> <b>code</b> <b>of</b> <b>common</b> <b>MUX</b> <b>service</b> <br />
<div class="fragment"><div class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> {</div><div class="line">     HOST_MUX_I2C_MASTER_BEGIN,</div><div class="line">     HOST_MUX_I2C_MASTER_0 = HOST_MUX_I2C_MASTER_BEGIN,</div><div class="line">     HOST_MUX_I2C_MASTER_1,</div><div class="line">     HOST_MUX_I2C_MASTER_END = HOST_MUX_I2C_MASTER_1,</div><div class="line">     HOST_MUX_SPI_MASTER_BEGIN,</div><div class="line">     HOST_MUX_SPI_MASTER_0 = HOST_MUX_SPI_MASTER_BEGIN,</div><div class="line">     HOST_MUX_SPI_MASTER_1,</div><div class="line">     HOST_MUX_SPI_MASTER_END = HOST_MUX_SPI_MASTER_1,</div><div class="line"></div><div class="line">     HOST_MUX_PORT_END,</div><div class="line"> } host_mux_port_t;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> {</div><div class="line">     HOST_MUX_STATUS_OK,</div><div class="line">     HOST_MUX_STATUS_ERROR,</div><div class="line">     HOST_MUX_STATUS_ERROR_PARAMETER,</div><div class="line">     HOST_MUX_STATUS_ERROR_INIT,</div><div class="line">     HOST_MUX_STATUS_ERROR_NOT_INIT,</div><div class="line">     HOST_MUX_STATUS_ERROR_INITIATED,</div><div class="line"> } host_mux_status_t;</div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;host_mux_portable.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;host_mux_spi_master_portable.h&quot;</span></div><div class="line"></div><div class="line"> host_mux_status_t host_mux_init(host_mux_port_t port)</div><div class="line"> {</div><div class="line">     host_mux_status_t status = HOST_MUX_STATUS_OK;</div><div class="line">     <span class="keywordflow">if</span>((port &gt;= HOST_MUX_I2C_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_I2C_MASTER_END))</div><div class="line">         status = portable_HAL_I2C_MASTER_INIT(port);</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((port &gt;= HOST_MUX_SPI_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_SPI_MASTER_END))</div><div class="line">         status = portable_HAL_SPI_MASTER_INIT(port);</div><div class="line">     <span class="keywordflow">return</span> status;</div><div class="line"> }</div><div class="line"></div><div class="line"> host_mux_status_t host_mux_deinit(host_mux_port_t port)</div><div class="line"> {</div><div class="line">     host_mux_status_t status = HOST_MUX_STATUS_OK;</div><div class="line">     <span class="keywordflow">if</span>((port &gt;= HOST_MUX_I2C_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_I2C_MASTER_END))</div><div class="line">         status = portable_HAL_I2C_MASTER_DEINIT(port);</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((port &gt;= HOST_MUX_SPI_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_SPI_MASTER_END))</div><div class="line">         status = portable_HAL_SPI_MASTER_DEINIT(port);</div><div class="line">     <span class="keywordflow">return</span> status;</div><div class="line"> }</div><div class="line"> host_mux_status_t host_mux_open(host_mux_port_t port,<span class="keywordtype">void</span>*user_data)</div><div class="line"> {</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"> host_mux_status_t host_mux_close(host_mux_port_t port)</div><div class="line"> {</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"> host_mux_status_t host_mux_rx(host_mux_port_t port, uint8_t*buffer, uint32_t *receive_done_data_len)</div><div class="line"> {</div><div class="line">     host_mux_status_t status = HOST_MUX_STATUS_OK;</div><div class="line">     <span class="keywordflow">if</span>((port &gt;= HOST_MUX_I2C_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_I2C_MASTER_END))</div><div class="line">            status = portable_HAL_I2C_MASTER_RX(port,buffer, receive_done_data_len);</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((port &gt;= HOST_MUX_SPI_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_SPI_MASTER_END))</div><div class="line">            status = portable_HAL_SPI_MASTER_RX(port,buffer, receive_done_data_len);</div><div class="line">        <span class="keywordflow">return</span> status;</div><div class="line"> }</div><div class="line"> host_mux_status_t host_mux_tx(host_mux_port_t port, uint8_t*buffer,uint32_t *send_done_data_len)</div><div class="line"> {</div><div class="line">     host_mux_status_t status = HOST_MUX_STATUS_OK;</div><div class="line">     <span class="keywordflow">if</span>((port &gt;= HOST_MUX_I2C_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_I2C_MASTER_END))</div><div class="line">         status = portable_HAL_I2C_MASTER_TX(port,buffer, send_done_data_len);</div><div class="line">     <span class="keywordflow">if</span>((port &gt;= HOST_MUX_SPI_MASTER_BEGIN) &amp;&amp; (port &lt;= HOST_MUX_SPI_MASTER_END))</div><div class="line">         status = portable_HAL_SPI_MASTER_TX(port,buffer, send_done_data_len);</div><div class="line">     <span class="keywordflow">return</span> status;</div><div class="line"> }</div></div><!-- fragment --></li>
<li><b>Master</b> <b>demo</b> <b>code</b> <b>of</b> <b>some</b> <b>common</b> <b>service</b> <b>portable</b> <b>layer</b> <br />
<div class="fragment"><div class="line"><span class="comment">//On this demo need to use some OS service of MUTX and semaphore</span></div><div class="line"><span class="preprocessor">#define portable_SemaphoreHandle_t SemaphoreHandle_t</span></div><div class="line"><span class="keywordtype">void</span> portable_MUTEX_TAKE(portable_SemaphoreHandle_t *p_sema_handle);</div><div class="line"><span class="keywordtype">void</span> portable_MUTEX_GIVE(portable_SemaphoreHandle_t *p_sema_handle);</div><div class="line"><span class="preprocessor">#define portable_xSemaphoreCreateMutex xSemaphoreCreateMutex</span></div><div class="line"><span class="preprocessor">#define portable_xSemaphoreCreateBinary xSemaphoreCreateBinary</span></div><div class="line"><span class="preprocessor">#define portable_xSemaphoreTake xSemaphoreTake</span></div><div class="line"><span class="preprocessor">#define portable_xSemaphoreGive xSemaphoreGive</span></div><div class="line"><span class="preprocessor">#define portable_xSemaphoreGiveFromISR xSemaphoreGiveFromISR</span></div><div class="line"></div><div class="line"><span class="comment">//On Arioha Chip, SPI master DMA only access non-cacheable buffer, and the buffer should be 4B align</span></div><div class="line"><span class="preprocessor">#define portable_Malloc_Non_cacheable pvPortMallocNC</span></div><div class="line"><span class="preprocessor">#define portable_Free_Non_cacheable vPortFreeNC</span></div><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> vPortFreeNC( <span class="keywordtype">void</span> *pv );</div><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> *pvPortMallocNC( <span class="keywordtype">size_t</span> xWantedSize );</div><div class="line"></div><div class="line"><span class="comment">//On this demo need to use busy loop delay</span></div><div class="line"><span class="preprocessor">#define portable_CPU_BUSY_LOOP_DELAY_US hal_gpt_delay_us</span></div><div class="line"><span class="preprocessor">#define portable_CPU_BUSY_LOOP_DELAY_MS hal_gpt_delay_ms</span></div><div class="line"></div><div class="line"> <span class="keywordtype">void</span> portable_MUTEX_TAKE(portable_SemaphoreHandle_t *p_sema_handle)</div><div class="line"> {</div><div class="line">     printf(<span class="stringliteral">&quot;portable_MUTEX_TASK\r\n&quot;</span>);</div><div class="line">     <span class="keywordflow">if</span> (portable_xSemaphoreTake(*p_sema_handle, portMAX_DELAY) == pdFALSE) {</div><div class="line">         printf(<span class="stringliteral">&quot;host mux portable_MUTEX_TAKE error\r\n&quot;</span>);</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">         <span class="keywordflow">return</span>;</div><div class="line">     }</div><div class="line"> }</div><div class="line"> <span class="keywordtype">void</span> portable_MUTEX_GIVE(portable_SemaphoreHandle_t *p_sema_handle)</div><div class="line"> {</div><div class="line">     printf(<span class="stringliteral">&quot;portable_MUTEX_GIVE\r\n&quot;</span>);</div><div class="line">     <span class="keywordflow">if</span> (portable_xSemaphoreGive(*p_sema_handle) == pdFALSE) {</div><div class="line">         printf(<span class="stringliteral">&quot;portable_MUTEX_GIVE error\r\n&quot;</span>);</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">         <span class="keywordflow">return</span>;</div><div class="line">     }</div><div class="line"> }</div></div><!-- fragment --></li>
<li><b>Master</b> <b>demo</b> <b>code</b> <b>of</b> <b>SPI</b> <b>master</b> <b>portable</b> <b>layer</b> <b>as</b> <b>below:</b> <br />
<div class="fragment"><div class="line"><span class="preprocessor"> #define MAX_ERROR_NUMBER 1000</span></div><div class="line"><span class="preprocessor"> #define SPIS_CFG_RD_CMD         0x0a</span></div><div class="line"><span class="preprocessor"> #define SPIS_RD_CMD             0x81</span></div><div class="line"><span class="preprocessor"> #define SPIS_CFG_WR_CMD         0x0c</span></div><div class="line"><span class="preprocessor"> #define SPIS_WR_CMD             0x0e</span></div><div class="line"><span class="preprocessor"> #define SPIS_RS_CMD             0x06</span></div><div class="line"><span class="preprocessor"> #define SPIS_WS_CMD             0x08</span></div><div class="line"><span class="preprocessor"> #define SPIS_PWON_CMD           0x04</span></div><div class="line"><span class="preprocessor"> #define SPIS_PWOFF_CMD          0x02</span></div><div class="line"><span class="preprocessor"> #define SPIS_CT_CMD             0x10</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#define VG_SPI_SLAVE_CMD_LEN 9 // The first word[31:16]: for cmd. he first word[15:0]::for reg index  The second word: for reg len</span></div><div class="line"> <span class="comment">//matser&lt;--&gt; slave CR or CW data format:</span></div><div class="line"> <span class="comment">//        Word 0:</span></div><div class="line"> <span class="comment">//           [31:16]- VG_SPI_SLAVE_CR_CMD or VG_SPI_SLAVE_CW_CMD</span></div><div class="line"> <span class="comment">//            [15:0]-   VG_SPI_SLAVE_xxx_xxx_REG_OFFSET</span></div><div class="line"> <span class="comment">//        Word:</span></div><div class="line"> <span class="comment">//            [31:0] Register len.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define VG_SPI_SLAVE_TX_LEN_REG_OFFSET 0x08</span></div><div class="line"><span class="preprocessor">#define VG_SPI_SLAVE_TX_BUF_REG_OFFSET 0x2000</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define VG_SPI_SLAVE_RX_LEN_REG_OFFSET 0x04</span></div><div class="line"><span class="preprocessor">#define VG_SPI_SLAVE_RX_BUF_REG_OFFSET 0x1000</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_SLV_ON_OFFSET           (0)</span></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_SLV_ON_MASK             (0x1&lt;&lt;HOST_MUX_SPIS_STA_SLV_ON_OFFSET)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_OFFSET    (2)</span></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK      (0x1&lt;&lt;HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_OFFSET)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_RDWR_FINISH_OFFSET      (5)</span></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_RDWR_FINISH_MASK        (0x1&lt;&lt;HOST_MUX_SPIS_STA_RDWR_FINISH_OFFSET)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_RD_ERR_OFFSET           (3)</span></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_RD_ERR_MASK             (0x1&lt;&lt;HOST_MUX_SPIS_STA_RD_ERR_OFFSET)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_WR_ERR_OFFSET           (4)</span></div><div class="line"><span class="preprocessor">#define HOST_MUX_SPIS_STA_WR_ERR_MASK             (0x1&lt;&lt;HOST_MUX_SPIS_STA_WR_ERR_OFFSET)</span></div><div class="line"></div><div class="line"> <span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t g_host_mux_spi_master_power_on_counter[<a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225af662eba7de8b35efcb6668e355790201">HAL_SPI_MASTER_MAX</a>] = {0};</div><div class="line"></div><div class="line"> <span class="keyword">static</span> portable_SemaphoreHandle_t g_host_mux_spi_master_mutex = NULL;</div><div class="line"></div><div class="line"> <span class="keyword">static</span> portable_SemaphoreHandle_t g_host_mux_spi_master_wait_send_done_xSemaphore = NULL;</div><div class="line"> <span class="keyword">static</span> portable_SemaphoreHandle_t g_host_mux_spi_master_wait_receive_done_xSemaphore = NULL;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">static</span> host_mux_status_t portable_HAL_SPI_POWER_ON(<a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> port);</div><div class="line"> <span class="keyword">static</span> host_mux_status_t portable_HAL_SPI_POWER_OFF(<a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> port);</div><div class="line"> <span class="keyword">static</span> host_mux_status_t portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(<a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> master_port,uint32_t bit_mask,uint32_t bit_value,uint32_t retry_counter);</div><div class="line"></div><div class="line"> <span class="keyword">static</span> host_mux_status_t portable_HAL_SPI_POWER_ON(<a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> port)</div><div class="line"> {</div><div class="line">     uint8_t poweron_cmd;</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_spi_master_power_on_counter[port] == 0){</div><div class="line">         <span class="keywordflow">while</span>(1){</div><div class="line">             poweron_cmd = SPIS_PWON_CMD;</div><div class="line">             <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> != <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2e3e29db046583116ca4b28582a98913">hal_spi_master_send_polling</a>(port, &amp;poweron_cmd, 1)) {</div><div class="line">                 printf(<span class="stringliteral">&quot;portable_HAL_SPI_POWER_ON ERROR. hal_spi_master_send_polling fail!!!\r\n&quot;</span>);</div><div class="line">                 <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR;</div><div class="line">             }</div><div class="line"></div><div class="line">             <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_SLV_ON_MASK,</div><div class="line">                 HOST_MUX_SPIS_STA_SLV_ON_MASK,1000)==HOST_MUX_STATUS_OK)</div><div class="line">                 <span class="keywordflow">break</span>;</div><div class="line">         }</div><div class="line">     }</div><div class="line">     g_host_mux_spi_master_power_on_counter[port] ++;</div><div class="line">     printf(<span class="stringliteral">&quot;portable_HAL_SPI_POWER_ON success!!!&quot;</span>);</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">static</span> host_mux_status_t portable_HAL_SPI_POWER_OFF(<a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> port)</div><div class="line"> {</div><div class="line">     uint8_t poweron_cmd;</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_spi_master_power_on_counter[port] == 0)</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_spi_master_power_on_counter[port] == 1){</div><div class="line">         <span class="keywordflow">while</span>(1){</div><div class="line">             poweron_cmd = SPIS_PWOFF_CMD;</div><div class="line">             <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> != <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2e3e29db046583116ca4b28582a98913">hal_spi_master_send_polling</a>(port, &amp;poweron_cmd, 1)) {</div><div class="line">             printf(<span class="stringliteral">&quot;portable_HAL_SPI_POWER_OFF ERROR. hal_spi_master_send_polling fail!!!\r\n&quot;</span>);</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR;</div><div class="line">             }</div><div class="line">             <span class="keywordflow">if</span>( portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_SLV_ON_MASK,0,1000) == HOST_MUX_STATUS_OK)</div><div class="line">                 <span class="keywordflow">break</span>;</div><div class="line">         }</div><div class="line">     }</div><div class="line">     g_host_mux_spi_master_power_on_counter[port] --;</div><div class="line">     printf(<span class="stringliteral">&quot;portable_HAL_SPI_POWER_OFF success!!!&quot;</span>);</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">static</span> host_mux_status_t portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(<a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> master_port,uint32_t bit_mask,uint32_t bit_value,uint32_t retry_counter)</div><div class="line"> {</div><div class="line">     uint8_t status_cmd = SPIS_RS_CMD;</div><div class="line">     uint8_t status_receive[2];</div><div class="line">     uint8_t clear_cmd_buf[2];</div><div class="line">     uint8_t status;</div><div class="line">     uint32_t i;</div><div class="line">     <a class="code" href="structhal__spi__master__send__and__receive__config__t.html">hal_spi_master_send_and_receive_config_t</a> spi_send_and_receive_config;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">// Note:</span></div><div class="line">     <span class="comment">// * The value of receive_length is the valid number of bytes received plus the number of bytes to send.</span></div><div class="line">     <span class="comment">// * For example, here the valid number of bytes received is 1 byte,</span></div><div class="line">     <span class="comment">// * and the number of bytes to send also is 1 byte, so the receive_length is 2.</span></div><div class="line"></div><div class="line">     <span class="keywordflow">for</span>(i=0;i&lt;retry_counter;i++)</div><div class="line">     {</div><div class="line">         status_receive[1] = 0;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#ad1caece1c6d018f189c43b60a8ab3439">receive_length</a> = 2;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a8e7eccfd5933bdf3c1b1f9fe67e9f2cf">send_length</a> = 1;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#add1fa76432b5a682cdaaf91f1869e9c2">send_data</a> = &amp;status_cmd;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a3745133ed122a18a121a277f2895b35b">receive_buffer</a> = status_receive;</div><div class="line">         <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> != <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#gaea9837d039cc19886d69ac619a9364b2">hal_spi_master_send_and_receive_polling</a>(master_port, &amp;spi_send_and_receive_config)) {</div><div class="line">             printf(<span class="stringliteral">&quot;portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY,SPI master query status of slave failed\r\n&quot;</span>);</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR;</div><div class="line">         }</div><div class="line">         printf(<span class="stringliteral">&quot;portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY  Status receive: 0x%x\r\n&quot;</span>, status_receive[1]);</div><div class="line">         status = status_receive[1];</div><div class="line">         <span class="keywordflow">if</span>(status &amp; (SPIS_STA_RD_ERR_MASK|SPIS_STA_WR_ERR_MASK) )<span class="comment">//|SPIS_STA_CMD_ERR_MASK</span></div><div class="line">         {</div><div class="line">             printf(<span class="stringliteral">&quot;portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY,Slave tansfer Error:%d, need reset Slave \r\n&quot;</span>,status);</div><div class="line">             clear_cmd_buf[0]= SPIS_WS_CMD;</div><div class="line">             clear_cmd_buf[1] = status;</div><div class="line">             <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> != <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2e3e29db046583116ca4b28582a98913">hal_spi_master_send_polling</a>(master_port,clear_cmd_buf,2)) {</div><div class="line">                 printf(<span class="stringliteral">&quot;portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY,SPI master query status of slave failed\r\n&quot;</span>);</div><div class="line">                 {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">                 <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR;</div><div class="line">             }</div><div class="line">             printf(<span class="stringliteral">&quot;Transfer error, now Master reset Slave!!!\r\n&quot;</span>);</div><div class="line">             portable_CPU_BUSY_LOOP_DELAY_US(100);</div><div class="line">             portable_HAL_SPI_POWER_OFF(master_port);</div><div class="line">             portable_HAL_SPI_POWER_ON(master_port);</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR;</div><div class="line">         }</div><div class="line">         <span class="keywordflow">else</span> <span class="keywordflow">if</span>((bit_mask &amp; status)== bit_value)</div><div class="line">         {</div><div class="line">             printf(<span class="stringliteral">&quot;portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY OK, retry counter:%d,\r\n&quot;</span>,(<span class="keywordtype">int</span>)i);</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line">         }</div><div class="line">         portable_CPU_BUSY_LOOP_DELAY_US(100);</div><div class="line">     }</div><div class="line">     printf(<span class="stringliteral">&quot;portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY, retry counter:%d,\r\n&quot;</span>,(<span class="keywordtype">int</span>)i);</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR;</div><div class="line"> }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_SPI_MASTER_wait_for_send_done()</div><div class="line"> {</div><div class="line">    <span class="keywordflow">if</span>(portable_xSemaphoreTake( g_host_mux_spi_master_wait_send_done_xSemaphore, portMAX_DELAY) == pdTRUE)</div><div class="line">    {</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">    }</div><div class="line"></div><div class="line"> }</div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_SPI_MASTER_wait_for_receive_done()</div><div class="line"> {</div><div class="line">    <span class="keywordflow">if</span>(portable_xSemaphoreTake( g_host_mux_spi_master_wait_receive_done_xSemaphore, portMAX_DELAY) == pdTRUE)</div><div class="line">    {</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">    }</div><div class="line"> }</div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_SPI_MASTER_RECEIVE_CB(<a class="code" href="group__hal__spi__master__enum.html#ga8fa97969f602af00a5552a0a7f2a4d9b">hal_spi_master_callback_event_t</a> event, <span class="keywordtype">void</span> *user_data)</div><div class="line"> {</div><div class="line">     BaseType_t xHigherPriorityTaskWoken = pdFALSE;</div><div class="line">     uint32_t receive_done_len = (uint32_t)user_data;</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span>(event == <a class="code" href="group__hal__spi__master__enum.html#gga8fa97969f602af00a5552a0a7f2a4d9bad01084fedd463f6d889a199a11fc16de">HAL_SPI_MASTER_EVENT_RECEIVE_FINISHED</a>)</div><div class="line">     {</div><div class="line">         printf(<span class="stringliteral">&quot;portable_HOST_MUX_SPI_MASTER_RECEIVE_CB receive_done_len:%d\r\n&quot;</span>,(<span class="keywordtype">int</span>)receive_done_len);</div><div class="line">         portable_xSemaphoreGiveFromISR( g_host_mux_spi_master_wait_receive_done_xSemaphore, &amp;xHigherPriorityTaskWoken );</div><div class="line"></div><div class="line">      }</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">     {</div><div class="line">         printf(<span class="stringliteral">&quot;portable_HOST_MUX_SPI_MASTER_RECEIVE_CB ERROR, err event:%d\r\n&quot;</span>,event);</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">     }</div><div class="line"></div><div class="line"> }</div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_SPI_MASTER_SEND_CB(<a class="code" href="group__hal__spi__master__enum.html#ga8fa97969f602af00a5552a0a7f2a4d9b">hal_spi_master_callback_event_t</a> event, <span class="keywordtype">void</span> *user_data)</div><div class="line"> {</div><div class="line">     BaseType_t xHigherPriorityTaskWoken = pdFALSE;</div><div class="line">     uint32_t send_done_len = (uint32_t)user_data;</div><div class="line">     <span class="keywordflow">if</span>(event == <a class="code" href="group__hal__spi__master__enum.html#gga8fa97969f602af00a5552a0a7f2a4d9bacf66f34e26f29f7a1ecdf214142ebf61">HAL_SPI_MASTER_EVENT_SEND_FINISHED</a>)</div><div class="line">     {</div><div class="line">         printf(<span class="stringliteral">&quot;portable_HOST_MUX_SPI_MASTER_SEND_CB send_done_len:%d\r\n&quot;</span>,(<span class="keywordtype">int</span>)send_done_len);</div><div class="line">         portable_xSemaphoreGiveFromISR( g_host_mux_spi_master_wait_send_done_xSemaphore, &amp;xHigherPriorityTaskWoken );</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">     {</div><div class="line">         printf(<span class="stringliteral">&quot;portable_HOST_MUX_SPI_MASTER_SEND_CB ERROR, err event:%d\r\n&quot;</span>,event);</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">     }</div><div class="line"> }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"> host_mux_status_t portable_HAL_SPI_MASTER_INIT(host_mux_port_t port)</div><div class="line"> {</div><div class="line"></div><div class="line">     <a class="code" href="structhal__spi__master__config__t.html">hal_spi_master_config_t</a> spi_master_config;</div><div class="line">     <a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> spi_port;</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_spi_master_mutex == NULL)</div><div class="line">         g_host_mux_spi_master_mutex = portable_xSemaphoreCreateMutex();</div><div class="line">     <span class="keywordflow">if</span> (g_host_mux_spi_master_mutex == NULL) {</div><div class="line">         printf( <span class="stringliteral">&quot;g_host_mux_spi_master_mutex create error\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_spi_master_wait_send_done_xSemaphore == NULL)</div><div class="line">         g_host_mux_spi_master_wait_send_done_xSemaphore = portable_xSemaphoreCreateBinary();</div><div class="line">     <span class="keywordflow">if</span> (g_host_mux_spi_master_wait_send_done_xSemaphore == NULL) {</div><div class="line">         printf( <span class="stringliteral">&quot;g_host_mux_spi_master_wait_send_done_xSemaphore create error\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_spi_master_wait_receive_done_xSemaphore == NULL)</div><div class="line">         g_host_mux_spi_master_wait_receive_done_xSemaphore = portable_xSemaphoreCreateBinary();</div><div class="line">     <span class="keywordflow">if</span> (g_host_mux_spi_master_wait_receive_done_xSemaphore == NULL) {</div><div class="line">         printf( <span class="stringliteral">&quot;g_host_mux_spi_master_wait_receive_done_xSemaphore create error\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span>(port == HOST_MUX_SPI_MASTER_0)</div><div class="line">            spi_port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a6ad168aae5253661ae3df3ec2694fae2">HAL_SPI_MASTER_0</a>;</div><div class="line">     <span class="keywordflow">if</span>(port == HOST_MUX_SPI_MASTER_1)</div><div class="line">            spi_port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a60707644b25de5a245265aecba6d4fae">HAL_SPI_MASTER_1</a>;</div><div class="line"></div><div class="line">     spi_master_config.<a class="code" href="structhal__spi__master__config__t.html#a5d94c69f3e000c69002ef7f409330109">bit_order</a> = <a class="code" href="group__hal__spi__master__enum.html#ggacc72e5d6aa5b8382a5b796a2d0502aeead503a96d94f9292b86a4c05864dad6ef">HAL_SPI_MASTER_LSB_FIRST</a>;</div><div class="line">     spi_master_config.<a class="code" href="structhal__spi__master__config__t.html#aaebf493dcf600ad25162bffe2d012a61">clock_frequency</a> = 1000000;</div><div class="line">     spi_master_config.<a class="code" href="structhal__spi__master__config__t.html#af70b0bce99a265eaa65c1d48a24901ff">phase</a> = <a class="code" href="group__hal__spi__master__enum.html#gga0f3c28243ab60f5f2f0cb106a387be9dad961414698d77aa164f16ceade0b6730">HAL_SPI_MASTER_CLOCK_PHASE0</a>;</div><div class="line">     spi_master_config.<a class="code" href="structhal__spi__master__config__t.html#a85cb36216a07880a648d911391de2c6a">polarity</a> = <a class="code" href="group__hal__spi__master__enum.html#gga55920393f83c5eac5320c9eef84eef1daec6706344a845381922715e19b9d9297">HAL_SPI_MASTER_CLOCK_POLARITY0</a>;</div><div class="line">     spi_master_config.<a class="code" href="structhal__spi__master__config__t.html#ab69d42d19d5b7eab72b1584b4fc2535d">slave_port</a> = <a class="code" href="group__hal__spi__master__enum.html#ggaa45624306338fbe20a1604d00a7abe79ad24600b896ad982be9af9164f2998cdd">HAL_SPI_MASTER_SLAVE_0</a>;</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> != <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2d28448fa4b9f877bb188d20578a0b30">hal_spi_master_init</a>(spi_port, &amp;spi_master_config)) {</div><div class="line">         printf( <span class="stringliteral">&quot;portable_HAL_SPI_MASTER_INIT hal_spi_master_init error!!!\r\n&quot;</span>);</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line">     <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga9a0e3ba08fb387d746b62611e222e2be">hal_spi_master_set_mode</a>(spi_port, <a class="code" href="group__hal__spi__master__enum.html#gga312a9cf8efd7f5eb1d6a1d8376299119afa1df65eeab7649f191d1235c5a95f76">HAL_SPI_MASTER_SINGLE_MODE</a>);</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"></div><div class="line"></div><div class="line"> host_mux_status_t portable_HAL_SPI_MASTER_DEINIT(host_mux_port_t port)</div><div class="line"> {</div><div class="line">   <a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> spi_port;</div><div class="line">   <span class="keywordflow">if</span>(port == HOST_MUX_SPI_MASTER_0)</div><div class="line">          spi_port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a6ad168aae5253661ae3df3ec2694fae2">HAL_SPI_MASTER_0</a>;</div><div class="line">   <span class="keywordflow">if</span>(port == HOST_MUX_SPI_MASTER_1)</div><div class="line">          spi_port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a60707644b25de5a245265aecba6d4fae">HAL_SPI_MASTER_1</a>;</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> != <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga8d5922ff4137c154e41a1b9dbc88109b">hal_spi_master_deinit</a>(spi_port)) {</div><div class="line">         printf( <span class="stringliteral">&quot;mux_spi_master_demo_deinit hal_spi_master_deinit error!!!\r\n&quot;</span>);</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">//     This is Master read data from slave:</span></div><div class="line"> <span class="comment">//     Step0: Power ON SPI slave</span></div><div class="line"> <span class="comment">//     Step1:Master read Slave the register of &lt;VG_SPI_SLAVE_TX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line"> <span class="comment">//          Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line"> <span class="comment">//                     Master send to slave 9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_TX_LEN_REG_OFFSET,[5:8] len-1</span></div><div class="line"> <span class="comment">//          Step1_b: Wait for SPI slave CR ready,check HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK.</span></div><div class="line"> <span class="comment">//          Step1_c: Master receive the value of &lt;VG_SPI_SLAVE_TX_LEN_REG_OFFSET&gt;</span></div><div class="line"> <span class="comment">//                Master receive 4 bytes, it&#39;s the data len which Slave prepared.</span></div><div class="line"> <span class="comment">//          Step1_d: Master query and check Slave_Tx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK.</span></div><div class="line"> <span class="comment">//     Step2:Master read Slave the register of &lt;VG_SPI_SLAVE_TX_BUF_REG_OFFSET&gt; with the len of data_buffer_len.</span></div><div class="line"> <span class="comment">//             Step2_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line"> <span class="comment">//                Master send to slave 9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_TX_BUF_REG_OFFSET,[5:8] len-1</span></div><div class="line"> <span class="comment">//             Step2_b: Wait for SPI slave CR ready,,check HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK.</span></div><div class="line"> <span class="comment">//             Step2_c: Master receive &lt;data_buffer_len&gt; data.</span></div><div class="line"> <span class="comment">//                     Master receive &lt;data_buffer_len&gt; bytes, it&#39;s the data which Slave prepared</span></div><div class="line"> <span class="comment">//             Step2_d:Master and check Slave_Tx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK.</span></div><div class="line"> <span class="comment">//      Step3: Power OFF</span></div><div class="line"></div><div class="line"></div><div class="line"> host_mux_status_t portable_HAL_SPI_MASTER_RX(host_mux_port_t mux_port, uint8_t*buf, uint32_t *receive_done_data_len)</div><div class="line"> {</div><div class="line">        <a class="code" href="structhal__spi__master__send__and__receive__config__t.html">hal_spi_master_send_and_receive_config_t</a> spi_send_and_receive_config;</div><div class="line">        <a class="code" href="group__hal__spi__master__enum.html#ga0f0acc31b5bd18a9d2a8ed8c72bac893">hal_spi_master_status_t</a> status;</div><div class="line">        uint8_t request_cmd[9];</div><div class="line">        uint32_t receive_reg_value;</div><div class="line">        uint32_t length,offset;</div><div class="line">        <span class="keyword">static</span> ATTR_ZIDATA_IN_NONCACHED_SYSRAM_4BYTE_ALIGN uint8_t temp_host_mux_send_buf[1];<span class="comment">//Airoha chip SPI master need the buffer 4B align</span></div><div class="line">        <span class="keyword">static</span> ATTR_ZIDATA_IN_NONCACHED_SYSRAM_4BYTE_ALIGN uint8_t temp_host_mux_receive_buf[4+1];<span class="comment">//Airoha chip SPI master need the buffer 4B align</span></div><div class="line">        <a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> port;</div><div class="line">         <span class="keywordflow">if</span>(mux_port == HOST_MUX_SPI_MASTER_0)</div><div class="line">             port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a6ad168aae5253661ae3df3ec2694fae2">HAL_SPI_MASTER_0</a>;</div><div class="line">         <span class="keywordflow">if</span>(mux_port == HOST_MUX_SPI_MASTER_1)</div><div class="line">             port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a60707644b25de5a245265aecba6d4fae">HAL_SPI_MASTER_1</a>;</div><div class="line"></div><div class="line">   <span class="comment">//Step0: Power ON SPI slave</span></div><div class="line">        portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">        portable_HAL_SPI_POWER_ON(port);</div><div class="line">        portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line"></div><div class="line"> mux_spi_master_demo_receive_restart:</div><div class="line">        portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">     <span class="comment">//Step1:Master read Slave the register of &lt;VG_SPI_SLAVE_TX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line">         <span class="comment">// Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">         <span class="comment">//            Master send to slave 9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_TX_LEN_REG_OFFSET,[5:8] len-1</span></div><div class="line">         length = 4;</div><div class="line">         offset = VG_SPI_SLAVE_TX_LEN_REG_OFFSET;</div><div class="line">         request_cmd[0] = SPIS_CFG_RD_CMD;</div><div class="line">         request_cmd[1] = offset &amp; 0xff;</div><div class="line">         request_cmd[2] = (offset &gt;&gt; 8) &amp; 0xff;</div><div class="line">         request_cmd[3] = (offset &gt;&gt; 16) &amp; 0xff;</div><div class="line">         request_cmd[4] = (offset &gt;&gt; 24) &amp; 0xff;</div><div class="line">         request_cmd[5] = (length - 1) &amp; 0xff;</div><div class="line">         request_cmd[6] = ((length - 1) &gt;&gt; 8) &amp; 0xff;</div><div class="line">         request_cmd[7] = ((length - 1) &gt;&gt; 16) &amp; 0xff;</div><div class="line">         request_cmd[8] = ((length - 1) &gt;&gt; 24) &amp; 0xff;</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_a: Send VG_SPI_SLAVE_CRD_CMD.\r\n&quot;</span>);</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_a: Master want to send 9B\r\n&quot;</span>);</div><div class="line">         status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2e3e29db046583116ca4b28582a98913">hal_spi_master_send_polling</a>(port,request_cmd,VG_SPI_SLAVE_CMD_LEN);</div><div class="line">         <span class="keywordflow">if</span>( <a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status){</div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_a: Send VG_SPI_SLAVE_CRD_CMD success!!!\r\n&quot;</span>);</div><div class="line">         }</div><div class="line">         <span class="keywordflow">else</span>{</div><div class="line">          printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_a:: SPI master send err, status:%d \r\n&quot;</span>,status);</div><div class="line">            {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">         }</div><div class="line"></div><div class="line">       <span class="comment">// Step1_b: Wait for SPI slave CR ready,check HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK</span></div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_b: wait slave CR done...\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,</div><div class="line">             HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,MAX_ERROR_NUMBER)==HOST_MUX_STATUS_ERROR)</div><div class="line">         {</div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_b: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">             portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">             <span class="keywordflow">goto</span> mux_spi_master_demo_receive_restart;</div><div class="line">         }</div><div class="line"></div><div class="line">         <span class="comment">//Step1_c: Master receive the value of &lt;VG_SPI_SLAVE_TX_LEN_REG_OFFSET&gt;</span></div><div class="line">         <span class="comment">//       Master receive 4 bytes, it&#39;s the data len which Slave prepared.</span></div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_c: Receive SPI slave Tx_len Reg value. \r\n&quot;</span>);</div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_c: Master want to receive 4B.\r\n&quot;</span>);</div><div class="line">             {</div><div class="line">                 temp_host_mux_send_buf[0] = SPIS_RD_CMD;</div><div class="line">                 spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#ad1caece1c6d018f189c43b60a8ab3439">receive_length</a> = 4+1;</div><div class="line">                 spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a8e7eccfd5933bdf3c1b1f9fe67e9f2cf">send_length</a> = 1;</div><div class="line">                 spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#add1fa76432b5a682cdaaf91f1869e9c2">send_data</a> = temp_host_mux_send_buf;</div><div class="line">                 spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a3745133ed122a18a121a277f2895b35b">receive_buffer</a> = temp_host_mux_receive_buf;</div><div class="line">                 status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#gaea9837d039cc19886d69ac619a9364b2">hal_spi_master_send_and_receive_polling</a>(port,&amp;spi_send_and_receive_config);</div><div class="line">                 <span class="keywordflow">if</span>( <a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status){</div><div class="line">                         <span class="comment">// Step1_d: Master query Slave_Tx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK</span></div><div class="line">                         <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,</div><div class="line">                         HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,MAX_ERROR_NUMBER)==HOST_MUX_STATUS_ERROR)</div><div class="line">                         {</div><div class="line">                             printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_d: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">                             portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">                             <span class="keywordflow">goto</span> mux_spi_master_demo_receive_restart;</div><div class="line">                         }</div><div class="line">                     receive_reg_value = temp_host_mux_receive_buf[1] | (temp_host_mux_receive_buf[2]&lt;&lt;8) | (temp_host_mux_receive_buf[3]&lt;&lt;16)|(temp_host_mux_receive_buf[3]&lt;&lt;24);</div><div class="line">                     printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_c: Receive SPI slave Tx_len Reg value:0x%x. success!!!\r\n&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)receive_reg_value);</div><div class="line">                 }</div><div class="line">                 <span class="keywordflow">else</span>{</div><div class="line">                     printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_c : SPI master receive err,status:%d\r\n&quot;</span>,status);</div><div class="line">                     {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">                 }</div><div class="line">             }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(receive_reg_value &gt; *receive_done_data_len){</div><div class="line">             receive_reg_value = *receive_done_data_len;</div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step1_c: slave data len too big, request %d B firstly;\r\n&quot;</span>,(<span class="keywordtype">int</span>)*receive_done_data_len);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span>(receive_reg_value == 0){</div><div class="line">             portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">             *receive_done_data_len = 0;</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line">        }</div><div class="line">        portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line"></div><div class="line"></div><div class="line">         portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">     <span class="comment">//Step2:Master read Slave the register of &lt;VG_SPI_SLAVE_TX_BUF_REG_OFFSET&gt; with the len of data_buffer_len.</span></div><div class="line">     <span class="comment">//        Step2_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">     <span class="comment">//           Master send to slave 9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_TX_BUF_REG_OFFSET,[5:8] len-1</span></div><div class="line">         length = receive_reg_value;</div><div class="line">         offset = VG_SPI_SLAVE_TX_BUF_REG_OFFSET;</div><div class="line">         request_cmd[0] = SPIS_CFG_RD_CMD;</div><div class="line">         request_cmd[1] = offset &amp; 0xff;</div><div class="line">         request_cmd[2] = (offset &gt;&gt; 8) &amp; 0xff;</div><div class="line">         request_cmd[3] = (offset &gt;&gt; 16) &amp; 0xff;</div><div class="line">         request_cmd[4] = (offset &gt;&gt; 24) &amp; 0xff;</div><div class="line">         request_cmd[5] = (length - 1) &amp; 0xff;</div><div class="line">         request_cmd[6] = ((length - 1) &gt;&gt; 8) &amp; 0xff;</div><div class="line">         request_cmd[7] = ((length - 1) &gt;&gt; 16) &amp; 0xff;</div><div class="line">         request_cmd[8] = ((length - 1) &gt;&gt; 24) &amp; 0xff;</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_a: send VG_SPI_SLAVE_RD_CMD.\r\n&quot;</span>);</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_a: Master want to send 9B cmd.\r\n&quot;</span>);</div><div class="line">         status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2e3e29db046583116ca4b28582a98913">hal_spi_master_send_polling</a>(port,request_cmd,VG_SPI_SLAVE_CMD_LEN);</div><div class="line">         <span class="keywordflow">if</span>( <a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status){</div><div class="line">          printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_a: Send VG_SPI_SLAVE_RD_CMD. success!!!\r\n&quot;</span>);</div><div class="line">         }</div><div class="line">         <span class="keywordflow">else</span>{</div><div class="line">            printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_a: SPI master send err, try again...status:%d \r\n&quot;</span>,status);</div><div class="line">            {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">         }</div><div class="line"></div><div class="line">      <span class="comment">// Step2_b: Wait for SPI slave CR ready</span></div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_b: wait slave CR done...\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,</div><div class="line">         HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,MAX_ERROR_NUMBER)==HOST_MUX_STATUS_ERROR)</div><div class="line">         {</div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_b: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">             portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">             <span class="keywordflow">goto</span> mux_spi_master_demo_receive_restart;</div><div class="line">         }</div><div class="line"></div><div class="line"></div><div class="line">         <span class="comment">//Step2_c: Master receive &lt;data_buffer_len&gt; data.</span></div><div class="line">         <span class="comment">//            Master receive &lt;data_buffer_len&gt; bytes, it&#39;s the data which Slave prepared.</span></div><div class="line">        <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga30178beaf6b2141f15046072d728d35a">hal_spi_master_register_callback</a>(port, portable_HOST_MUX_SPI_MASTER_RECEIVE_CB, (<span class="keywordtype">void</span> *)receive_reg_value);<span class="comment">//Register a user callback.</span></div><div class="line">         temp_host_mux_send_buf[0] = SPIS_RD_CMD;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#ad1caece1c6d018f189c43b60a8ab3439">receive_length</a> = receive_reg_value+1;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a8e7eccfd5933bdf3c1b1f9fe67e9f2cf">send_length</a> = 1;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#add1fa76432b5a682cdaaf91f1869e9c2">send_data</a> = temp_host_mux_send_buf;</div><div class="line">         spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a3745133ed122a18a121a277f2895b35b">receive_buffer</a> = buf;</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_c: Master want to receive:%d\r\n&quot;</span>,(<span class="keywordtype">int</span>)receive_reg_value);</div><div class="line"></div><div class="line">            status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga9aac26dc29a7fac7d8fbee80e48a2048">hal_spi_master_send_and_receive_dma</a>(port, &amp;spi_send_and_receive_config);</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status) {</div><div class="line">                 portable_HOST_MUX_SPI_MASTER_wait_for_receive_done();</div><div class="line">                 <span class="comment">//Step2_d:Master and check Slave_Tx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK.</span></div><div class="line">                     <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,</div><div class="line">                     HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,MAX_ERROR_NUMBER)==HOST_MUX_STATUS_ERROR)</div><div class="line">                     {</div><div class="line">                         printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_d: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">                         portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">                         <span class="keywordflow">goto</span> mux_spi_master_demo_receive_restart;</div><div class="line">                     }</div><div class="line">                 printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_c: Receive Tx_buff data. success\r\n&quot;</span>);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span>{</div><div class="line">              printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_c: hal_spi_master_send_and_receive_dma return ERROR!!! status:%d\r\n&quot;</span>,status);</div><div class="line">                {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">            }</div><div class="line">        portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">      *receive_done_data_len = receive_reg_value;</div><div class="line"></div><div class="line">    <span class="comment">//Step3: Power OFF SPI slave</span></div><div class="line">        portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">        portable_HAL_SPI_POWER_OFF(port);</div><div class="line">        portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">      <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"></div><div class="line">   <span class="comment">//  This is Master write data to slave:</span></div><div class="line">   <span class="comment">//  Step1:Master read Slave the register of &lt;VG_SPI_SLAVE_RX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line">   <span class="comment">//          Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">   <span class="comment">//              Master send to slave 9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_RX_LEN_REG_OFFSET,[5:8] len-1</span></div><div class="line">   <span class="comment">//          Step1_b: Wait for SPI slave CR ready</span></div><div class="line">   <span class="comment">//          Step1_c: Master receive the value of &lt;VG_SPI_SLAVE_RX_LEN_REG_OFFSET&gt;</span></div><div class="line">   <span class="comment">//                   Master receive 4 bytes, it&#39;s the data len which Slave prepared.</span></div><div class="line">   <span class="comment">//          Step1_d: Master query and check Slave_Tx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK.</span></div><div class="line">   <span class="comment">//  Step2:Master read Slave the register of &lt;VG_SPI_SLAVE_RX_BUF_REG_OFFSET&gt; with the len of data_buffer_len which master want to write.</span></div><div class="line">   <span class="comment">//          Step2_a: Master send Config Write (CW) cmd to slave:</span></div><div class="line">   <span class="comment">//              Master send to slave9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_TX_BUF_REG_OFFSET,[5:8] len-1</span></div><div class="line">   <span class="comment">//          Step2_b: Wait for SPI slave CR ready</span></div><div class="line">   <span class="comment">//          Step2_c: Master send &lt;data_buffer_len&gt; data.</span></div><div class="line">   <span class="comment">//              Slave address is DEMO_SPI_SLAVE_ADDRESS_W</span></div><div class="line">   <span class="comment">//              Master send &lt;data_buffer_len&gt; bytes, it&#39;s the data which master want to write.</span></div><div class="line">   <span class="comment">//          Step2_d:Master and check Slave_Rx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK.</span></div><div class="line"></div><div class="line"></div><div class="line"> host_mux_status_t portable_HAL_SPI_MASTER_TX(host_mux_port_t mux_port, uint8_t*buf, uint32_t *send_done_data_len)</div><div class="line"> {</div><div class="line">        <a class="code" href="structhal__spi__master__send__and__receive__config__t.html">hal_spi_master_send_and_receive_config_t</a> spi_send_and_receive_config;</div><div class="line">        <a class="code" href="group__hal__spi__master__enum.html#ga0f0acc31b5bd18a9d2a8ed8c72bac893">hal_spi_master_status_t</a> status;</div><div class="line">        uint8_t request_cmd[9];</div><div class="line">        uint32_t receive_reg_value;</div><div class="line">        uint32_t length,offset;</div><div class="line">        uint8_t* p_temp_malloc_buff;</div><div class="line">        <span class="keyword">static</span> ATTR_ZIDATA_IN_NONCACHED_SYSRAM_4BYTE_ALIGN uint8_t temp_host_mux_send_buf[1];<span class="comment">//Airoha chip SPI master need the buffer 4B align</span></div><div class="line">        <span class="keyword">static</span> ATTR_ZIDATA_IN_NONCACHED_SYSRAM_4BYTE_ALIGN uint8_t temp_host_mux_receive_buf[4+1];<span class="comment">//Airoha chip SPI master need the buffer 4B align</span></div><div class="line">         <a class="code" href="group__hal__spi__master__enum.html#gabd1845e0e1bea2d6a73d32ec69ac8225">hal_spi_master_port_t</a> port;</div><div class="line">         <span class="keywordflow">if</span>(mux_port == HOST_MUX_SPI_MASTER_0)</div><div class="line">             port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a6ad168aae5253661ae3df3ec2694fae2">HAL_SPI_MASTER_0</a>;</div><div class="line">         <span class="keywordflow">if</span>(mux_port == HOST_MUX_SPI_MASTER_1)</div><div class="line">             port =  <a class="code" href="group__hal__spi__master__enum.html#ggabd1845e0e1bea2d6a73d32ec69ac8225a60707644b25de5a245265aecba6d4fae">HAL_SPI_MASTER_1</a>;</div><div class="line">    <span class="comment">//Step0: Power ON SPI slave</span></div><div class="line">         portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">         portable_HAL_SPI_POWER_ON(port);</div><div class="line">         portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line"></div><div class="line"> mux_spi_master_demo_send_restart:</div><div class="line"></div><div class="line">     portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">     <span class="comment">//Step1:Master read Slave the register of &lt;VG_SPI_SLAVE_RX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line">     <span class="comment">//        Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">     <span class="comment">//            Master send to slave 9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_RX_LEN_REG_OFFSET,[5:8] len-1</span></div><div class="line">     length = 4;</div><div class="line">     offset = VG_SPI_SLAVE_RX_LEN_REG_OFFSET;</div><div class="line">     request_cmd[0] = SPIS_CFG_RD_CMD;</div><div class="line">     request_cmd[1] = offset &amp; 0xff;</div><div class="line">     request_cmd[2] = (offset &gt;&gt; 8) &amp; 0xff;</div><div class="line">     request_cmd[3] = (offset &gt;&gt; 16) &amp; 0xff;</div><div class="line">     request_cmd[4] = (offset &gt;&gt; 24) &amp; 0xff;</div><div class="line">     request_cmd[5] = (length - 1) &amp; 0xff;</div><div class="line">     request_cmd[6] = ((length - 1) &gt;&gt; 8) &amp; 0xff;</div><div class="line">     request_cmd[7] = ((length - 1) &gt;&gt; 16) &amp; 0xff;</div><div class="line">     request_cmd[8] = ((length - 1) &gt;&gt; 24) &amp; 0xff;</div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_a: Send VG_SPI_SLAVE_CRD_CMD.\r\n&quot;</span>);</div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_a: Master want to send 9B cmd.\r\n&quot;</span>);</div><div class="line">     status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2e3e29db046583116ca4b28582a98913">hal_spi_master_send_polling</a>(port,request_cmd,VG_SPI_SLAVE_CMD_LEN);</div><div class="line">     <span class="keywordflow">if</span>( <a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status){</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_a: Send VG_SPI_SLAVE_CRD_CMD success!!!\r\n&quot;</span>);</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span>{</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_a: SPI master send err, try again...status:%d \r\n&quot;</span>,status);</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">     }</div><div class="line">     <span class="comment">// Step1_b: Wait for SPI slave CR ready</span></div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_b: wait slave CR done...\r\n&quot;</span>);</div><div class="line">     <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,</div><div class="line">     HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,MAX_ERROR_NUMBER)== HOST_MUX_STATUS_ERROR)</div><div class="line">     {</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_b: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">         portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">         <span class="keywordflow">goto</span> mux_spi_master_demo_send_restart;</div><div class="line">     }</div><div class="line">     <span class="comment">//Step1_c: Master receive the value of &lt;VG_SPI_SLAVE_RX_LEN_REG_OFFSET&gt;</span></div><div class="line">     <span class="comment">//                 Master receive 4 bytes, it&#39;s the data len which Slave prepared.</span></div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_c: receive SPI slave Tx_len Reg value.\r\n&quot;</span>);</div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_c: Master want to receive 4B.\r\n&quot;</span>);</div><div class="line">     temp_host_mux_send_buf[0] = SPIS_RD_CMD;</div><div class="line">     spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#ad1caece1c6d018f189c43b60a8ab3439">receive_length</a> = 4+1;</div><div class="line">     spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a8e7eccfd5933bdf3c1b1f9fe67e9f2cf">send_length</a> = 1;</div><div class="line">     spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#add1fa76432b5a682cdaaf91f1869e9c2">send_data</a> = temp_host_mux_send_buf;</div><div class="line">     spi_send_and_receive_config.<a class="code" href="structhal__spi__master__send__and__receive__config__t.html#a3745133ed122a18a121a277f2895b35b">receive_buffer</a> = temp_host_mux_receive_buf;</div><div class="line">     status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#gaea9837d039cc19886d69ac619a9364b2">hal_spi_master_send_and_receive_polling</a>(port,&amp;spi_send_and_receive_config);</div><div class="line">     <span class="keywordflow">if</span>( <a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status){</div><div class="line">         <span class="comment">//Step1_d: Master query and check Slave_Tx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK.</span></div><div class="line">         <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,</div><div class="line">         HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,MAX_ERROR_NUMBER)==HOST_MUX_STATUS_ERROR)</div><div class="line">         {</div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_d: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">             portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">             <span class="keywordflow">goto</span> mux_spi_master_demo_send_restart;</div><div class="line">         }</div><div class="line">         receive_reg_value = temp_host_mux_receive_buf[1] | (temp_host_mux_receive_buf[2]&lt;&lt;8) | (temp_host_mux_receive_buf[3]&lt;&lt;16)|(temp_host_mux_receive_buf[3]&lt;&lt;24);</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_c: Receive SPI slave Rx_len Reg value:0x%x. success!!!\r\n&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)receive_reg_value);</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span>{</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_c: SPI master receive err, try again...status:%d\r\n&quot;</span>,status);</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">     }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(receive_reg_value &gt; *send_done_data_len){</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_c: Receive SPI slave Rx_len Reg value:%d, but master just want to send:%d\r\n&quot;</span>,(<span class="keywordtype">int</span>)receive_reg_value,(<span class="keywordtype">int</span>)*send_done_data_len);</div><div class="line">         receive_reg_value = *send_done_data_len;</div><div class="line">     }</div><div class="line">    <span class="keywordflow">if</span>(receive_reg_value == 0){</div><div class="line">         portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">         *send_done_data_len = 0;</div><div class="line">         <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line">    }</div><div class="line">    portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line"></div><div class="line">    portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line"></div><div class="line">     <span class="comment">//Step2:Master read Slave the register of &lt;VG_SPI_SLAVE_RX_BUF_REG_OFFSET&gt; with the len of data_buffer_len which master want to write.</span></div><div class="line">     <span class="comment">//        Step2_a: Master send Config Write (CW) cmd to slave:</span></div><div class="line">    <span class="comment">//             Master send to slave9 bytes cmd: [0]:SPIS_CFG_RD_CMD, [1:4]VG_SPI_SLAVE_TX_BUF_REG_OFFSET,[5:8] len-1</span></div><div class="line">     length = receive_reg_value;</div><div class="line">     offset = VG_SPI_SLAVE_RX_BUF_REG_OFFSET;</div><div class="line">     request_cmd[0] = SPIS_CFG_WR_CMD;</div><div class="line">     request_cmd[1] = offset &amp; 0xff;</div><div class="line">     request_cmd[2] = (offset &gt;&gt; 8) &amp; 0xff;</div><div class="line">     request_cmd[3] = (offset &gt;&gt; 16) &amp; 0xff;</div><div class="line">     request_cmd[4] = (offset &gt;&gt; 24) &amp; 0xff;</div><div class="line">     request_cmd[5] = (length - 1) &amp; 0xff;</div><div class="line">     request_cmd[6] = ((length - 1) &gt;&gt; 8) &amp; 0xff;</div><div class="line">     request_cmd[7] = ((length - 1) &gt;&gt; 16) &amp; 0xff;</div><div class="line">     request_cmd[8] = ((length - 1) &gt;&gt; 24) &amp; 0xff;</div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_a: send VG_SPI_SLAVE_WD_CMD.\r\n&quot;</span>);</div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_a:Master want to send 8B \r\n&quot;</span>);</div><div class="line">     status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga2e3e29db046583116ca4b28582a98913">hal_spi_master_send_polling</a>(port,request_cmd,VG_SPI_SLAVE_CMD_LEN);</div><div class="line">     <span class="keywordflow">if</span>( <a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status)</div><div class="line">     {</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_a: Send VG_SPI_SLAVE_RD_CMD. success!!!\r\n&quot;</span>);</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span>{</div><div class="line">        printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_a: SPI master send err, try again...status:%d \r\n&quot;</span>,status);</div><div class="line">        {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">     }</div><div class="line">     <span class="comment">// Step2_b: Wait for SPI slave CR ready</span></div><div class="line">     printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_b: wait slave CR done...\r\n&quot;</span>);</div><div class="line">     <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,</div><div class="line">             HOST_MUX_SPIS_STA_TXRX_FIFO_RDY_MASK,MAX_ERROR_NUMBER)==HOST_MUX_STATUS_ERROR)</div><div class="line">     {</div><div class="line">         printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step1_d: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">         portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">         <span class="keywordflow">goto</span> mux_spi_master_demo_send_restart;</div><div class="line">     }</div><div class="line">     <span class="comment">//Step2_c: Master send &lt;data_buffer_len&gt; data.</span></div><div class="line">    <span class="comment">//         Slave address is DEMO_SPI_SLAVE_ADDRESS_W</span></div><div class="line">     <span class="comment">//        Master send &lt;data_buffer_len&gt; bytes, it&#39;s the data which master want to write.</span></div><div class="line"></div><div class="line">         <span class="comment">//Just for SPI master design behavior of : the buf address must be alignment with 4B</span></div><div class="line">         p_temp_malloc_buff = NULL;</div><div class="line">         <span class="keywordflow">if</span>((uint32_t)buf % 4 != 0){</div><div class="line">            p_temp_malloc_buff= portable_Malloc_Non_cacheable(receive_reg_value+1);</div><div class="line">            memcpy(p_temp_malloc_buff+1,buf,receive_reg_value);</div><div class="line">            buf = p_temp_malloc_buff;</div><div class="line">         }</div><div class="line"></div><div class="line">        <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga30178beaf6b2141f15046072d728d35a">hal_spi_master_register_callback</a>(port, portable_HOST_MUX_SPI_MASTER_SEND_CB, (<span class="keywordtype">void</span> *)receive_reg_value);<span class="comment">//Register a user callback.</span></div><div class="line">        printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_c:Master want to send:%d\r\n&quot;</span>,(<span class="keywordtype">int</span>)receive_reg_value);</div><div class="line">        printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_c: master send data. buf address:0x%x\r\n&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)buf);</div><div class="line">        buf[0] = SPIS_WR_CMD;</div><div class="line">        status = <a class="code" href="group___s_p_i___m_a_s_t_e_r.html#ga1fbbba16d4b8405a32b7486b8bda7c4b">hal_spi_master_send_dma</a>(port, buf, receive_reg_value+1);</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__hal__spi__master__enum.html#gga0f0acc31b5bd18a9d2a8ed8c72bac893a81be3701725eae22b23859c2de16a5ef">HAL_SPI_MASTER_STATUS_OK</a> == status) {</div><div class="line">             portable_HOST_MUX_SPI_MASTER_wait_for_send_done();</div><div class="line">                 <span class="comment">//Step2_d:Master and check Slave_Rx done status,check HOST_MUX_SPIS_STA_RDWR_FINISH_MASK.</span></div><div class="line">                 <span class="keywordflow">if</span>(portable_HOST_SPI_MASTER_QUERY_SLAVE_STATUS_WITH_RETRY(port,HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,</div><div class="line">                 HOST_MUX_SPIS_STA_RDWR_FINISH_MASK,MAX_ERROR_NUMBER)==HOST_MUX_STATUS_ERROR)</div><div class="line">                 {</div><div class="line">                     printf(<span class="stringliteral">&quot;mux_spi_master_demo_receive-Step2_d: #### too many ERROR, now go to restart!!!!!\r\n&quot;</span>);</div><div class="line">                     portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">                     <span class="keywordflow">goto</span> mux_spi_master_demo_send_restart;</div><div class="line">                 }</div><div class="line">              printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_c: receive Tx_buff data. success\r\n&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span>{</div><div class="line">             printf(<span class="stringliteral">&quot;mux_spi_master_demo_send-Step2_c: send fail!!!status:%d\r\n&quot;</span>,status);</div><div class="line">            {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">        }</div><div class="line">  <span class="keywordflow">if</span>(p_temp_malloc_buff != NULL)</div><div class="line">         portable_Free_Non_cacheable(p_temp_malloc_buff);</div><div class="line">      portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">      *send_done_data_len = receive_reg_value;</div><div class="line"></div><div class="line">   <span class="comment">//Step3: Power OFF SPI slave</span></div><div class="line">        portable_MUTEX_TAKE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">        portable_HAL_SPI_POWER_OFF(port);</div><div class="line">        portable_MUTEX_GIVE(&amp;g_host_mux_spi_master_mutex);</div><div class="line">      <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div></div><!-- fragment --></li>
<li><b>Master</b> <b>demo</b> <b>code</b> <b>of</b> <b>I2C</b> <b>master</b> <b>portable</b> <b>layer</b> <b>as</b> <b>below:</b> <br />
<div class="fragment"><div class="line"><span class="preprocessor">#define ENABLE_ERROR_RETRY</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line"><span class="preprocessor">    #define MAX_ERROR_NUMBER 1000</span></div><div class="line">     <span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t g_i2c_master_send_error_counter = 0;</div><div class="line">     <span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t g_i2c_master_receive_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#define VG_I2C_SLAVE_CR_CMD 0xaa51</span></div><div class="line"><span class="preprocessor">#define VG_I2C_SLAVE_CW_CMD 0xaa53</span></div><div class="line"> <span class="comment">// The first word[31:16]: for cmd. he first word[15:0]::for reg index  The second word: for reg len</span></div><div class="line"><span class="preprocessor">#define VG_I2C_SLAVE_CMD_LEN 8</span></div><div class="line"> <span class="comment">//matser&lt;--&gt; slave CR or CW data format:</span></div><div class="line"> <span class="comment">//        Word 0:</span></div><div class="line"> <span class="comment">//            [31:16]- VG_I2C_SLAVE_CR_CMD or VG_I2C_SLAVE_CW_CMD</span></div><div class="line"> <span class="comment">//            [15:0]-   VG_I2C_SLAVE_xxx_xxx_REG_OFFSET</span></div><div class="line"> <span class="comment">//        Word:</span></div><div class="line"> <span class="comment">//            [31:0] Register len.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define VG_I2C_SLAVE_TX_LEN_REG_OFFSET 0x08</span></div><div class="line"><span class="preprocessor">#define VG_I2C_SLAVE_TX_BUF_REG_OFFSET 0x2000</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define VG_I2C_SLAVE_RX_LEN_REG_OFFSET 0x04</span></div><div class="line"><span class="preprocessor">#define VG_I2C_SLAVE_RX_BUF_REG_OFFSET 0x1000</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW 0x50//(0x30)//</span></div><div class="line"><span class="preprocessor">#define DEMO_I2C_SLAVE_ADDRESS_R        0x54//(0xa1)//</span></div><div class="line"><span class="preprocessor">#define DEMO_I2C_SLAVE_ADDRESS_W        0x58//(0xa2)//</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">static</span> <span class="keyword">volatile</span> int32_t send_irq_err_flag = 0;</div><div class="line"> <span class="keyword">static</span> <span class="keyword">volatile</span> int32_t receive_irq_err_flag = 0;</div><div class="line"></div><div class="line"> <span class="keyword">static</span> SemaphoreHandle_t g_host_mux_i2c_master_mutex = NULL;</div><div class="line"> <span class="keyword">static</span> SemaphoreHandle_t g_host_mux_i2c_master_wait_send_done_xSemaphore = NULL;</div><div class="line"> <span class="keyword">static</span> SemaphoreHandle_t g_host_mux_i2c_master_wait_receive_done_xSemaphore = NULL;</div><div class="line"></div><div class="line"></div><div class="line"> host_mux_status_t portable_HAL_I2C_MASTER_INIT(host_mux_port_t port)</div><div class="line"> {</div><div class="line">     <a class="code" href="structhal__i2c__config__t.html">hal_i2c_config_t</a> i2c_config;</div><div class="line">     <a class="code" href="group__hal__i2c__master__enum.html#ga33635cb73931b5c10aa2a3e9019a99a1">hal_i2c_port_t</a> i2c_port;</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_i2c_master_mutex == NULL)</div><div class="line">         g_host_mux_i2c_master_mutex = portable_xSemaphoreCreateMutex();</div><div class="line">     <span class="keywordflow">if</span> (g_host_mux_i2c_master_mutex == NULL) {</div><div class="line">         printf( <span class="stringliteral">&quot;g_host_mux_i2c_master_mutex create error\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_i2c_master_wait_send_done_xSemaphore == NULL)</div><div class="line">         g_host_mux_i2c_master_wait_send_done_xSemaphore = portable_xSemaphoreCreateBinary();</div><div class="line">     <span class="keywordflow">if</span> (g_host_mux_i2c_master_wait_send_done_xSemaphore == NULL) {</div><div class="line">         printf( <span class="stringliteral">&quot;g_host_mux_i2c_master_wait_send_done_xSemaphore create error\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line">     <span class="keywordflow">if</span>(g_host_mux_i2c_master_wait_receive_done_xSemaphore == NULL)</div><div class="line">         g_host_mux_i2c_master_wait_receive_done_xSemaphore = portable_xSemaphoreCreateBinary();</div><div class="line">     <span class="keywordflow">if</span> (g_host_mux_i2c_master_wait_receive_done_xSemaphore == NULL) {</div><div class="line">         printf( <span class="stringliteral">&quot;g_host_mux_i2c_master_wait_receive_done_xSemaphore create error\r\n&quot;</span>);</div><div class="line">         <span class="keywordflow">return</span> HOST_MUX_STATUS_ERROR_INIT;</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span>(port == HOST_MUX_I2C_MASTER_0)</div><div class="line">        i2c_port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a9c2124ce9eadb3be2173217fa1e006fa">HAL_I2C_MASTER_0</a>;</div><div class="line">     <span class="keywordflow">if</span>(port == HOST_MUX_I2C_MASTER_1)</div><div class="line">        i2c_port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a3c7f5bbccf4f7e2486eac4336aa356c6">HAL_I2C_MASTER_1</a>;</div><div class="line"></div><div class="line">     i2c_config.<a class="code" href="structhal__i2c__config__t.html#aad1115ea33f65f77d5c8c7cba9b60891">frequency</a> = <a class="code" href="group__hal__i2c__master__enum.html#ggac655e07e449f6119dee3954bc0aca621a97f92ab5a85a5de919fa125739b10f3d">HAL_I2C_FREQUENCY_50K</a>;</div><div class="line">     <span class="keywordflow">if</span>(<a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == <a class="code" href="group___i2_c___m_a_s_t_e_r.html#ga394ae57aa938600ff37af7954d77036c">hal_i2c_master_init</a>(i2c_port, &amp;i2c_config)){</div><div class="line">         <a class="code" href="group___i2_c___m_a_s_t_e_r.html#ga6e55a57437776571722124e30ff24d33">hal_i2c_master_set_io_config</a>(i2c_port,<a class="code" href="group__hal__i2c__master__enum.html#ggab5f3946fbc56d8f0c9f811c48b88e8dbae97945ce89169dc27021f4f7fbb7923b">HAL_I2C_IO_PUSH_PULL</a>);</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span>{</div><div class="line">         printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive: open fail, try next time...\r\n&quot;</span>);</div><div class="line">         {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">     }</div><div class="line">    <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"></div><div class="line"> }</div><div class="line"> host_mux_status_t portable_HAL_I2C_MASTER_DEINIT(host_mux_port_t port)</div><div class="line"> {</div><div class="line">     <a class="code" href="group__hal__i2c__master__enum.html#ga33635cb73931b5c10aa2a3e9019a99a1">hal_i2c_port_t</a> i2c_port;</div><div class="line">     <span class="keywordflow">if</span>(port == HOST_MUX_I2C_MASTER_0)</div><div class="line">       i2c_port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a9c2124ce9eadb3be2173217fa1e006fa">HAL_I2C_MASTER_0</a>;</div><div class="line">     <span class="keywordflow">if</span>(port == HOST_MUX_I2C_MASTER_1)</div><div class="line">       i2c_port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a3c7f5bbccf4f7e2486eac4336aa356c6">HAL_I2C_MASTER_1</a>;</div><div class="line">     <span class="keywordflow">if</span>(<a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> != <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaf18b1bd591c70438e9781086dc066927">hal_i2c_master_deinit</a>(i2c_port)){</div><div class="line">            printf(<span class="stringliteral">&quot;hal_i2c_master_deinit: deinit fail!!!\r\n&quot;</span>);</div><div class="line">         }</div><div class="line">     <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_I2C_MASTER_wait_for_send_done()</div><div class="line"> {</div><div class="line">    <span class="keywordflow">if</span>(portable_xSemaphoreTake( g_host_mux_i2c_master_wait_send_done_xSemaphore, portMAX_DELAY) == pdTRUE)</div><div class="line">    {</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">    }</div><div class="line"></div><div class="line"> }</div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_I2C_MASTER_wait_for_receive_done()</div><div class="line"> {</div><div class="line">    <span class="keywordflow">if</span>(portable_xSemaphoreTake( g_host_mux_i2c_master_wait_receive_done_xSemaphore, portMAX_DELAY) == pdTRUE)</div><div class="line">    {</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        {printf(<span class="stringliteral">&quot;Assert!!!&quot;</span>);     <span class="keywordflow">while</span>(1);    assert(0);}</div><div class="line">    }</div><div class="line"> }</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_I2C_MASTER_RECEIVE_CB(uint8_t slave_address, <a class="code" href="group__hal__i2c__master__enum.html#ga58fc50836e76bbacb833ad1a3099f3eb">hal_i2c_callback_event_t</a> event, <span class="keywordtype">void</span> *user_data)</div><div class="line"> {</div><div class="line">     BaseType_t xHigherPriorityTaskWoken = pdFALSE;</div><div class="line">     uint32_t receive_done_len = (uint32_t)user_data;</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span>(event == <a class="code" href="group__hal__i2c__master__enum.html#gga58fc50836e76bbacb833ad1a3099f3eba299d23139f90e941a09bfd4938069599">HAL_I2C_EVENT_SUCCESS</a>)</div><div class="line">     {</div><div class="line">         receive_irq_err_flag = 1;</div><div class="line">          <span class="comment">//printf(&quot;receive done: &lt;%s&gt;\r\n&quot;,receive_data_buf);</span></div><div class="line">      }</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">     {</div><div class="line">         receive_irq_err_flag = -1;</div><div class="line">         printf(<span class="stringliteral">&quot;i2c_user_receive_callback ERROR, err event:%d\r\n&quot;</span>,event);</div><div class="line">     }</div><div class="line">     portable_xSemaphoreGiveFromISR( g_host_mux_i2c_master_wait_receive_done_xSemaphore, &amp;xHigherPriorityTaskWoken );</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> portable_HOST_MUX_I2C_MASTER_SEND_CB(uint8_t slave_address, <a class="code" href="group__hal__i2c__master__enum.html#ga58fc50836e76bbacb833ad1a3099f3eb">hal_i2c_callback_event_t</a> event, <span class="keywordtype">void</span> *user_data)</div><div class="line"> {</div><div class="line">     BaseType_t xHigherPriorityTaskWoken = pdFALSE;</div><div class="line">     uint32_t send_done_len = (uint32_t)user_data;</div><div class="line">     <span class="keywordflow">if</span>(event == <a class="code" href="group__hal__i2c__master__enum.html#gga58fc50836e76bbacb833ad1a3099f3eba299d23139f90e941a09bfd4938069599">HAL_I2C_EVENT_SUCCESS</a>)</div><div class="line">     {</div><div class="line">         send_irq_err_flag= 1;</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">     {</div><div class="line">         send_irq_err_flag = -1;</div><div class="line">         printf(<span class="stringliteral">&quot;i2c_user_send_callback ERROR, err event:%d\r\n&quot;</span>,event);</div><div class="line">     }</div><div class="line">     portable_xSemaphoreGiveFromISR( g_host_mux_i2c_master_wait_send_done_xSemaphore, &amp;xHigherPriorityTaskWoken );</div><div class="line"> }</div><div class="line"></div><div class="line">  <span class="comment">//   This is Master read data from slave:</span></div><div class="line">  <span class="comment">//   Step0: Init I2C master</span></div><div class="line">  <span class="comment">//   Step1:Master read Slave the register of &lt;VG_I2C_SLAVE_TX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line">  <span class="comment">//           Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">  <span class="comment">//               Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line">  <span class="comment">//               Master send to slave two word:{(VG_I2C_SLAVE_CR_CMD&lt;&lt;16)|VG_I2C_SLAVE_TX_LEN_REG_OFFSET,4}</span></div><div class="line">  <span class="comment">//           Step1_b: Master receive the value of &lt;VG_I2C_SLAVE_TX_LEN_REG_OFFSET&gt;</span></div><div class="line">  <span class="comment">//              Slave address is DEMO_I2C_SLAVE_ADDRESS_R</span></div><div class="line">  <span class="comment">//              Master receive 4 bytes, it&#39;s the data len which Slave prepared.</span></div><div class="line">  <span class="comment">//   Step2:Master read Slave the register of &lt;VG_I2C_SLAVE_TX_BUF_REG_OFFSET&gt; with the len of data_buffer_len.</span></div><div class="line">  <span class="comment">//           Step2_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">  <span class="comment">//               Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line">  <span class="comment">//               Master send to slave two word:{(VG_I2C_SLAVE_CR_CMD&lt;&lt;16)|VG_I2C_SLAVE_TX_BUF_REG_OFFSET,data_buffer_len}</span></div><div class="line">  <span class="comment">//           Step2_b: Master receive &lt;data_buffer_len&gt; data.</span></div><div class="line">  <span class="comment">//               Slave address is DEMO_I2C_SLAVE_ADDRESS_R</span></div><div class="line">  <span class="comment">//               Master receive &lt;data_buffer_len&gt; bytes, it&#39;s the data which Slave prepared.</span></div><div class="line">  <span class="comment">//   Step3: Deinit I2C master</span></div><div class="line"></div><div class="line"> host_mux_status_t portable_HAL_I2C_MASTER_RX(host_mux_port_t mux_port, uint8_t*buf, uint32_t *receive_done_data_len)</div><div class="line"> {</div><div class="line">        <a class="code" href="structhal__i2c__receive__config__t.html">hal_i2c_receive_config_t</a> receive_config;</div><div class="line">        <a class="code" href="group__hal__i2c__master__enum.html#gad3ddfb889b2b8f2c4fc497e5fa0b0e5f">hal_i2c_status_t</a> status;</div><div class="line">        uint32_t request_cmd[2];</div><div class="line">        uint32_t receive_reg_value = 0;</div><div class="line">         <a class="code" href="group__hal__i2c__master__enum.html#ga33635cb73931b5c10aa2a3e9019a99a1">hal_i2c_port_t</a> port;</div><div class="line">         <span class="keywordflow">if</span>(mux_port == HOST_MUX_I2C_MASTER_0)</div><div class="line">             port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a9c2124ce9eadb3be2173217fa1e006fa">HAL_I2C_MASTER_0</a>;</div><div class="line">         <span class="keywordflow">if</span>(mux_port == HOST_MUX_I2C_MASTER_1)</div><div class="line">             port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a3c7f5bbccf4f7e2486eac4336aa356c6">HAL_I2C_MASTER_1</a>;</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line"> mux_i2c_master_demo_receive_restart:</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        portable_MUTEX_TAKE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">     <span class="comment">//Step1:Master read Slave the register of &lt;VG_I2C_SLAVE_TX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line">   <span class="comment">//       Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">   <span class="comment">//                  Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line">   <span class="comment">//                  Master send to slave two word:{(VG_I2C_SLAVE_CR_CMD&lt;&lt;16)|VG_I2C_SLAVE_TX_LEN_REG_OFFSET,4}</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">     g_i2c_master_receive_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">       request_cmd[0] = (VG_I2C_SLAVE_CR_CMD&lt;&lt;16) | VG_I2C_SLAVE_TX_LEN_REG_OFFSET;</div><div class="line">       request_cmd[1] = 4;</div><div class="line">       <span class="keywordflow">while</span>(1){</div><div class="line">         printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_a: Send VG_I2C_SLAVE_CRD_CMD.\r\n&quot;</span>);</div><div class="line">         printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_a: Switch I2C Slave address to :0x%x. Master want to send 8B\r\n&quot;</span>,DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW);</div><div class="line">         status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaedb65edccb74cee22fb6dba9a9c13a48">hal_i2c_master_send_polling</a>(port, DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW,(uint8_t *)request_cmd,VG_I2C_SLAVE_CMD_LEN);</div><div class="line">         <span class="keywordflow">if</span>( <a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status){</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_a: Send VG_I2C_SLAVE_CRD_CMD success!!!\r\n&quot;</span>);</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">         }</div><div class="line">          printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_a: I2C master send err, try again...status:%d \r\n&quot;</span>,status);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">             g_i2c_master_receive_error_counter++;</div><div class="line">             <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">                 printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_a: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">                 portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">                <span class="keywordflow">goto</span> mux_i2c_master_demo_receive_restart;</div><div class="line">             }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">       }</div><div class="line">         <span class="comment">//Step1_b: Master receive the value of &lt;VG_I2C_SLAVE_TX_LEN_REG_OFFSET&gt;</span></div><div class="line">         <span class="comment">//       Slave address is DEMO_I2C_SLAVE_ADDRESS_R</span></div><div class="line">         <span class="comment">//       Master receive 4 bytes, it&#39;s the data len which Slave prepared.</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">        g_i2c_master_receive_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">while</span>(1)</div><div class="line">        {</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_b: Receive I2C slave Tx_len Reg value. \r\n&quot;</span>);</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_b: Switch I2C Slave address to :0x%x.Master want to receive 4B.\r\n&quot;</span>,</div><div class="line">                     DEMO_I2C_SLAVE_ADDRESS_R);</div><div class="line">             status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#ga592b4d37ba885854a3d5b090f7873ff9">hal_i2c_master_receive_polling</a>(port, DEMO_I2C_SLAVE_ADDRESS_R, (uint8_t*)&amp;receive_reg_value, 4);</div><div class="line">             <span class="keywordflow">if</span>( <a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status){</div><div class="line">                 printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_b: Receive I2C slave Tx_len Reg value:0x%x. success!!!\r\n&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)receive_reg_value);</div><div class="line">                 <span class="keywordflow">break</span>;</div><div class="line">             }</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_b : I2C master receive err, try again...status:%d\r\n&quot;</span>,(<span class="keywordtype">int</span>)status);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">                         g_i2c_master_receive_error_counter++;</div><div class="line">                         <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">                             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_b: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">                             portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">                            <span class="keywordflow">goto</span> mux_i2c_master_demo_receive_restart;</div><div class="line">                         }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span>(receive_reg_value &gt; *receive_done_data_len){</div><div class="line">             receive_reg_value = *receive_done_data_len;</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step1_b: slave data len too big, request %d B firstly;\r\n&quot;</span>,(<span class="keywordtype">int</span>)*receive_done_data_len);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span>(receive_reg_value == 0){</div><div class="line">             portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">             *receive_done_data_len = 0;</div><div class="line">             <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line">        }</div><div class="line">        portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line"></div><div class="line"></div><div class="line">     portable_MUTEX_TAKE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line"></div><div class="line">     <span class="comment">//Step2:Master read Slave the register of &lt;VG_I2C_SLAVE_TX_BUF_REG_OFFSET&gt; with the len of data_buffer_len.</span></div><div class="line">     <span class="comment">//        Step2_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">     <span class="comment">//            Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line">     <span class="comment">//            Master send to slave two word:{(VG_I2C_SLAVE_CR_CMD&lt;&lt;16)|VG_I2C_SLAVE_TX_BUF_REG_OFFSET,data_buffer_len}</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">            g_i2c_master_receive_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        request_cmd[0] = (VG_I2C_SLAVE_CR_CMD&lt;&lt;16) | VG_I2C_SLAVE_TX_BUF_REG_OFFSET;</div><div class="line">        request_cmd[1] = receive_reg_value;</div><div class="line">        <span class="keywordflow">while</span>(1){</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_a: send VG_I2C_SLAVE_RD_CMD.\r\n&quot;</span>);</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_a: Switch I2C Slave address to :0x%x.Master want to send 8B cmd.\r\n&quot;</span>,DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW);</div><div class="line">            status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaedb65edccb74cee22fb6dba9a9c13a48">hal_i2c_master_send_polling</a>(port, DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW,(uint8_t *)request_cmd,VG_I2C_SLAVE_CMD_LEN);</div><div class="line">            <span class="keywordflow">if</span>( <a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status){</div><div class="line">              printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_a: Send VG_I2C_SLAVE_RD_CMD. success!!!\r\n&quot;</span>);</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_a: I2C master send err, try again...status:%d \r\n&quot;</span>,status);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">            g_i2c_master_receive_error_counter++;</div><div class="line">            <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">                printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_a: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">                portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">               <span class="keywordflow">goto</span> mux_i2c_master_demo_receive_restart;</div><div class="line">            }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        }</div><div class="line">         <span class="comment">//Step2_b: Master receive &lt;data_buffer_len&gt; data.</span></div><div class="line">         <span class="comment">//            Slave address is DEMO_I2C_SLAVE_ADDRESS_R</span></div><div class="line">         <span class="comment">//            Master receive &lt;data_buffer_len&gt; bytes, it&#39;s the data which Slave prepared.</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">        g_i2c_master_receive_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaa7d6d97628a15624e29610d5ec7e95d9">hal_i2c_master_register_callback</a>(port, portable_HOST_MUX_I2C_MASTER_RECEIVE_CB, (<span class="keywordtype">void</span> *)receive_reg_value);<span class="comment">//Register a user callback.</span></div><div class="line">        receive_config.<a class="code" href="structhal__i2c__receive__config__t.html#ad81f00c0eed8787156afee31c8480205">receive_bytes_in_one_packet</a> = receive_reg_value;</div><div class="line">        receive_config.<a class="code" href="structhal__i2c__receive__config__t.html#a3745133ed122a18a121a277f2895b35b">receive_buffer</a> = buf;</div><div class="line">        receive_config.<a class="code" href="structhal__i2c__receive__config__t.html#ad5e96a5aceb9aaff6428af0c2a6cc7d1">receive_packet_length</a> = 1;</div><div class="line">        receive_config.<a class="code" href="structhal__i2c__receive__config__t.html#ac93868aeda435dfb685a0a0020e5c7a4">slave_address</a> = DEMO_I2C_SLAVE_ADDRESS_R;</div><div class="line">        printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_b: Switch I2C Slave address to :0x%x,Master want to receive:%d\r\n&quot;</span>,</div><div class="line">         DEMO_I2C_SLAVE_ADDRESS_R,(<span class="keywordtype">int</span>)receive_reg_value);</div><div class="line">        <span class="keywordflow">while</span>(1){</div><div class="line">            receive_irq_err_flag = 0;</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_b: receive Tx_buff data.  \r\n&quot;</span>);</div><div class="line">            status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaab30d6f1dfd1cae999897dee3bce5b91">hal_i2c_master_receive_dma_ex</a>(port, &amp;receive_config);</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status) {</div><div class="line">                 portable_HOST_MUX_I2C_MASTER_wait_for_receive_done();</div><div class="line">                 <span class="keywordflow">if</span>(receive_irq_err_flag == 1){</div><div class="line">                     printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_b: Receive Tx_buff data. success\r\n&quot;</span>);</div><div class="line">                     <span class="keywordflow">break</span>;</div><div class="line">                 }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span>{</div><div class="line">              printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_b: hal_i2c_master_receive_dma_ex return ERROR!!! status:%d\r\n&quot;</span>,status);</div><div class="line">                 <span class="keywordflow">while</span>(1);</div><div class="line">                assert(0);</div><div class="line">            }</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_b: I2C master receive err, try again...\r\n&quot;</span>);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">           g_i2c_master_receive_error_counter++;</div><div class="line">           <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">               printf(<span class="stringliteral">&quot;mux_i2c_master_demo_receive-Step2_b: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">               portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">              <span class="keywordflow">goto</span> mux_i2c_master_demo_receive_restart;</div><div class="line">           }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">      }</div><div class="line">      portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">      *receive_done_data_len = receive_reg_value;</div><div class="line">      <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">//    This is Master write data to slave:</span></div><div class="line"> <span class="comment">//    Step0: Init I2C master</span></div><div class="line"> <span class="comment">//    Step1:Master read Slave the register of &lt;VG_I2C_SLAVE_RX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line"> <span class="comment">//            Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line"> <span class="comment">//                Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line"> <span class="comment">//                Master send to slave two word:{(VG_I2C_SLAVE_CR_CMD&lt;&lt;16)|VG_I2C_SLAVE_RX_LEN_REG_OFFSET,4}</span></div><div class="line"> <span class="comment">//            Step1_b: Master receive the value of &lt;VG_I2C_SLAVE_RX_LEN_REG_OFFSET&gt;</span></div><div class="line"> <span class="comment">//               Slave address is DEMO_I2C_SLAVE_ADDRESS_R</span></div><div class="line"> <span class="comment">//               Master receive 4 bytes, it&#39;s the data len which Slave Rx buffer free size.</span></div><div class="line"> <span class="comment">//    Step2:Master read Slave the register of &lt;VG_I2C_SLAVE_RX_BUF_REG_OFFSET&gt; with the len of data_buffer_len which master want to write.</span></div><div class="line"> <span class="comment">//            Step2_a: Master send Config Write (CW) cmd to slave:</span></div><div class="line"> <span class="comment">//                Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line"> <span class="comment">//                Master send to slave two word:{(VG_I2C_SLAVE_CW_CMD&lt;&lt;16)|VG_I2C_SLAVE_RX_BUF_REG_OFFSET,data_buffer_len}</span></div><div class="line"> <span class="comment">//            Step2_b: Master send &lt;data_buffer_len&gt; data.</span></div><div class="line"> <span class="comment">//                Slave address is DEMO_I2C_SLAVE_ADDRESS_W</span></div><div class="line"> <span class="comment">//                Master send &lt;data_buffer_len&gt; bytes, it&#39;s the data which master want to write.</span></div><div class="line"> <span class="comment">//    Step3: Deinit I2C master</span></div><div class="line"></div><div class="line"> host_mux_status_t portable_HAL_I2C_MASTER_TX(host_mux_port_t mux_port, uint8_t*buf, uint32_t *send_done_data_len)</div><div class="line"> {</div><div class="line">        <a class="code" href="structhal__i2c__send__config__t.html">hal_i2c_send_config_t</a> send_config;</div><div class="line">        <a class="code" href="group__hal__i2c__master__enum.html#gad3ddfb889b2b8f2c4fc497e5fa0b0e5f">hal_i2c_status_t</a> status;</div><div class="line">        uint32_t request_cmd[2];</div><div class="line">        uint32_t receive_reg_value;</div><div class="line">        <a class="code" href="group__hal__i2c__master__enum.html#ga33635cb73931b5c10aa2a3e9019a99a1">hal_i2c_port_t</a> port;</div><div class="line">        <span class="keywordflow">if</span>(mux_port == HOST_MUX_I2C_MASTER_0)</div><div class="line">            port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a9c2124ce9eadb3be2173217fa1e006fa">HAL_I2C_MASTER_0</a>;</div><div class="line">        <span class="keywordflow">if</span>(mux_port == HOST_MUX_I2C_MASTER_1)</div><div class="line">            port =  <a class="code" href="group__hal__i2c__master__enum.html#gga33635cb73931b5c10aa2a3e9019a99a1a3c7f5bbccf4f7e2486eac4336aa356c6">HAL_I2C_MASTER_1</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">        mux_i2c_master_demo_send_restart:</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">     portable_MUTEX_TAKE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">     <span class="comment">//Step1:Master read Slave the register of &lt;VG_I2C_SLAVE_RX_LEN_REG_OFFSET&gt; with the len of 4</span></div><div class="line">     <span class="comment">//    Step1_a: Master send Config Read (CR) cmd to slave:</span></div><div class="line">     <span class="comment">//        Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line">     <span class="comment">//        Master send to slave two word:{(VG_I2C_SLAVE_CR_CMD&lt;&lt;16)|VG_I2C_SLAVE_RX_LEN_REG_OFFSET,4}</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">         g_i2c_master_send_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">         request_cmd[0] = (VG_I2C_SLAVE_CR_CMD&lt;&lt;16) | VG_I2C_SLAVE_RX_LEN_REG_OFFSET;</div><div class="line">         request_cmd[1] = 4;</div><div class="line">         <span class="keywordflow">while</span>(1){</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_a: Send VG_I2C_SLAVE_CRD_CMD.\r\n&quot;</span>);</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_a: Switch I2C Slave address to :0x%x. Master want to send 8B cmd.\r\n&quot;</span>,DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW);</div><div class="line">             status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaedb65edccb74cee22fb6dba9a9c13a48">hal_i2c_master_send_polling</a>(port, DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW,(uint8_t *)request_cmd,VG_I2C_SLAVE_CMD_LEN);</div><div class="line">         <span class="keywordflow">if</span>( <a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status){</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_a: Send VG_I2C_SLAVE_CRD_CMD success!!!\r\n&quot;</span>);</div><div class="line">             <span class="keywordflow">break</span>;</div><div class="line">         }</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_a: I2C master send err, try again...status:%d \r\n&quot;</span>,status);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">           g_i2c_master_receive_error_counter++;</div><div class="line">           <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">               printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_a: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">               portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">              <span class="keywordflow">goto</span> mux_i2c_master_demo_send_restart;</div><div class="line">           }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">         }</div><div class="line"></div><div class="line">     <span class="comment">//Step1_b: Master receive the value of &lt;VG_I2C_SLAVE_RX_LEN_REG_OFFSET&gt;</span></div><div class="line">     <span class="comment">//           Slave address is DEMO_I2C_SLAVE_ADDRESS_R</span></div><div class="line">     <span class="comment">//           Master receive 4 bytes, it&#39;s the data len which Slave Rx buffer free size.</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">                 g_i2c_master_send_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">while</span>(1){</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_b: receive I2C slave Tx_len Reg value.\r\n&quot;</span>);</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_b: Switch I2C Slave address to :0x%x.Master want to receive 4B.\r\n&quot;</span>,DEMO_I2C_SLAVE_ADDRESS_R);</div><div class="line">             status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#ga592b4d37ba885854a3d5b090f7873ff9">hal_i2c_master_receive_polling</a>(port, DEMO_I2C_SLAVE_ADDRESS_R, (uint8_t*)&amp;receive_reg_value, 4);</div><div class="line">             <span class="keywordflow">if</span>( <a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status){</div><div class="line">                 printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_b: Receive I2C slave Rx_len Reg value:0x%x. success!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)receive_reg_value);</div><div class="line">                 <span class="keywordflow">break</span>;</div><div class="line">             }</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_b: I2C master receive err, try again...status:%d\r\n&quot;</span>,status);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">           g_i2c_master_receive_error_counter++;</div><div class="line">           <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">               printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_b: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">               portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">              <span class="keywordflow">goto</span> mux_i2c_master_demo_send_restart;</div><div class="line">           }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span>(receive_reg_value &gt; *send_done_data_len){</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step1_b: Receive I2C slave Rx_len Reg value:%d, but master just want to send:%d\r\n&quot;</span>,(<span class="keywordtype">int</span>)receive_reg_value,(<span class="keywordtype">int</span>)*send_done_data_len);</div><div class="line">             receive_reg_value = *send_done_data_len;</div><div class="line">         }</div><div class="line">        <span class="keywordflow">if</span>(receive_reg_value == 0){</div><div class="line">             portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">              *send_done_data_len = 0;</div><div class="line">                 <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line">        }</div><div class="line">        portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line"></div><div class="line">        portable_MUTEX_TAKE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">     <span class="comment">//Step2:Master read Slave the register of &lt;VG_I2C_SLAVE_RX_BUF_REG_OFFSET&gt; with the len of data_buffer_len which master want to write.</span></div><div class="line">     <span class="comment">//    Step2_a: Master send Config Write (CW) cmd to slave:</span></div><div class="line">     <span class="comment">//        Slave address is DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW.</span></div><div class="line">     <span class="comment">//        Master send to slave two word:{(VG_I2C_SLAVE_CW_CMD&lt;&lt;16)|VG_I2C_SLAVE_RX_BUF_REG_OFFSET,data_buffer_len}</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">        g_i2c_master_send_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        request_cmd[0] = (VG_I2C_SLAVE_CW_CMD&lt;&lt;16) | VG_I2C_SLAVE_RX_BUF_REG_OFFSET;</div><div class="line">        request_cmd[1] = receive_reg_value;</div><div class="line">        <span class="keywordflow">while</span>(1){</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_a: send VG_I2C_SLAVE_WD_CMD.\r\n&quot;</span>);</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_a: Switch I2C Slave address to :0x%x.Master want to send 8B \r\n&quot;</span>,DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW);</div><div class="line">            status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaedb65edccb74cee22fb6dba9a9c13a48">hal_i2c_master_send_polling</a>(port, DEMO_I2C_SLAVE_ADDRESS_CR_OR_CW,(uint8_t *)request_cmd,VG_I2C_SLAVE_CMD_LEN);</div><div class="line">            <span class="keywordflow">if</span>( <a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status)</div><div class="line">            {</div><div class="line">              printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_a: Send VG_I2C_SLAVE_RD_CMD. success!!!\r\n&quot;</span>);</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_a: I2C master send err, try again...status:%d \r\n&quot;</span>,status);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">          g_i2c_master_receive_error_counter++;</div><div class="line">          <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">              printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_a: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">              portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">             <span class="keywordflow">goto</span> mux_i2c_master_demo_send_restart;</div><div class="line">          }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        }</div><div class="line">     <span class="comment">//Step2_b: Master send &lt;data_buffer_len&gt; data.</span></div><div class="line">     <span class="comment">//        Slave address is DEMO_I2C_SLAVE_ADDRESS_W</span></div><div class="line">     <span class="comment">//        Master send &lt;data_buffer_len&gt; bytes, it&#39;s the data which master want to write.</span></div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">        g_i2c_master_send_error_counter = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <a class="code" href="group___i2_c___m_a_s_t_e_r.html#gaa7d6d97628a15624e29610d5ec7e95d9">hal_i2c_master_register_callback</a>(port, portable_HOST_MUX_I2C_MASTER_SEND_CB, (<span class="keywordtype">void</span> *)receive_reg_value);<span class="comment">//Register a user callback.</span></div><div class="line">        send_config.<a class="code" href="structhal__i2c__send__config__t.html#acd3b03c4662daa03fa34b5c45afd6278">send_bytes_in_one_packet</a> = receive_reg_value;</div><div class="line">        send_config.<a class="code" href="structhal__i2c__send__config__t.html#ad0c90e0dbe62c37e1c53d6d869ee635d">send_data</a> = buf;</div><div class="line">        send_config.<a class="code" href="structhal__i2c__send__config__t.html#afeb3cf68ab69d32aea71089023171ad3">send_packet_length</a> = 1;</div><div class="line">        send_config.<a class="code" href="structhal__i2c__send__config__t.html#ac93868aeda435dfb685a0a0020e5c7a4">slave_address</a> = DEMO_I2C_SLAVE_ADDRESS_W;</div><div class="line">        printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_b: Switch I2C Slave address to :0x%x. Master want to send:%d\r\n&quot;</span>,</div><div class="line">                                     DEMO_I2C_SLAVE_ADDRESS_W,(<span class="keywordtype">int</span>)receive_reg_value);</div><div class="line">        <span class="keywordflow">while</span>(1){</div><div class="line">            <span class="comment">//hal_gpt_delay_ms(10);</span></div><div class="line">            send_irq_err_flag = 0;</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_b: master send data. \r\n&quot;</span>);</div><div class="line">            status = <a class="code" href="group___i2_c___m_a_s_t_e_r.html#ga4607bfa74fad8eb5664c72d97226e2d3">hal_i2c_master_send_dma_ex</a>(port, &amp;send_config);</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group__hal__i2c__master__enum.html#ggad3ddfb889b2b8f2c4fc497e5fa0b0e5fabb768e77cd5626c1a2c07417bee446e0">HAL_I2C_STATUS_OK</a> == status) {</div><div class="line">                 portable_HOST_MUX_I2C_MASTER_wait_for_send_done();</div><div class="line">                 <span class="keywordflow">if</span>(send_irq_err_flag == 1){</div><div class="line">                     printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_b: receive Tx_buff data. success\r\n&quot;</span>);</div><div class="line">                     <span class="keywordflow">break</span>;</div><div class="line">                 }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span>{</div><div class="line">                 printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_b: send fail!!!status:%d\r\n&quot;</span>,status);</div><div class="line">                 <span class="keywordflow">while</span>(1);</div><div class="line">                assert(0);</div><div class="line">            }</div><div class="line">            printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_b: I2C master receive err, try again...\r\n&quot;</span>);</div><div class="line"><span class="preprocessor">#ifdef ENABLE_ERROR_RETRY</span></div><div class="line">         g_i2c_master_receive_error_counter++;</div><div class="line">         <span class="keywordflow">if</span>(g_i2c_master_receive_error_counter&gt;MAX_ERROR_NUMBER){</div><div class="line">             printf(<span class="stringliteral">&quot;mux_i2c_master_demo_send-Step2_a: #### too many ERROR counter %d, now go to restart!!!!!\r\n&quot;</span>,(<span class="keywordtype">int</span>)g_i2c_master_receive_error_counter);</div><div class="line">             portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">            <span class="keywordflow">goto</span> mux_i2c_master_demo_send_restart;</div><div class="line">         }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">      }</div><div class="line">      portable_MUTEX_GIVE(&amp;g_host_mux_i2c_master_mutex);</div><div class="line">      *send_done_data_len = receive_reg_value;</div><div class="line">      <span class="keywordflow">return</span> HOST_MUX_STATUS_OK;</div><div class="line"> }</div></div><!-- fragment --> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa5a6637a907492337e5ba1584e8566ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gaa5a6637a907492337e5ba1584e8566ac">mux_init</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, <a class="el" href="structmux__port__setting__t.html">mux_port_setting_t</a> *setting, <a class="el" href="structmux__protocol__t.html">mux_protocol_t</a> *protocol_callback)</td></tr>
<tr class="memdesc:gaa5a6637a907492337e5ba1584e8566ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mux port initialize.  <a href="#gaa5a6637a907492337e5ba1584e8566ac">More...</a><br /></td></tr>
<tr class="separator:gaa5a6637a907492337e5ba1584e8566ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b5602fbc1fc88e0fe4aa7859fe63ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gab2b5602fbc1fc88e0fe4aa7859fe63ba">mux_deinit</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port)</td></tr>
<tr class="memdesc:gab2b5602fbc1fc88e0fe4aa7859fe63ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mux port deinitialize.  <a href="#gab2b5602fbc1fc88e0fe4aa7859fe63ba">More...</a><br /></td></tr>
<tr class="separator:gab2b5602fbc1fc88e0fe4aa7859fe63ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fae99a7203d897ca65791172d5476ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga8fae99a7203d897ca65791172d5476ba">mux_exception_init</a> (<a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle)</td></tr>
<tr class="memdesc:ga8fae99a7203d897ca65791172d5476ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is logging port exception initialize, special for mux port as logging port.  <a href="#ga8fae99a7203d897ca65791172d5476ba">More...</a><br /></td></tr>
<tr class="separator:ga8fae99a7203d897ca65791172d5476ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c07f1835ce9f510fcc853f61d7c131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga62c07f1835ce9f510fcc853f61d7c131">mux_exception_send</a> (<a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle, const <a class="el" href="structmux__buffer__t.html">mux_buffer_t</a> *buffers, uint32_t buffers_counter)</td></tr>
<tr class="memdesc:ga62c07f1835ce9f510fcc853f61d7c131"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is logging port send exception data, special for mux port as logging port.  <a href="#ga62c07f1835ce9f510fcc853f61d7c131">More...</a><br /></td></tr>
<tr class="separator:ga62c07f1835ce9f510fcc853f61d7c131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06ec73160c0f545d2c54db34cb48b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gab06ec73160c0f545d2c54db34cb48b2c">mux_open</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, const char *user_name, <a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> *p_handle, <a class="el" href="group__mux__struct.html#ga12d58527190c649788f79955e5d475d3">mux_callback_t</a> callback, void *user_data)</td></tr>
<tr class="memdesc:gab06ec73160c0f545d2c54db34cb48b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mux port open by user.  <a href="#gab06ec73160c0f545d2c54db34cb48b2c">More...</a><br /></td></tr>
<tr class="separator:gab06ec73160c0f545d2c54db34cb48b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd4b17060da7e6b45627bceda61d7d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gabd4b17060da7e6b45627bceda61d7d28">mux_close</a> (<a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle)</td></tr>
<tr class="memdesc:gabd4b17060da7e6b45627bceda61d7d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mux port close by user.  <a href="#gabd4b17060da7e6b45627bceda61d7d28">More...</a><br /></td></tr>
<tr class="separator:gabd4b17060da7e6b45627bceda61d7d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aab70691132af097f69a6fca720d1e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga5aab70691132af097f69a6fca720d1e8">mux_rx</a> (<a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle, <a class="el" href="structmux__buffer__t.html">mux_buffer_t</a> *buffer, uint32_t *receive_done_data_len)</td></tr>
<tr class="memdesc:ga5aab70691132af097f69a6fca720d1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mux receive data.  <a href="#ga5aab70691132af097f69a6fca720d1e8">More...</a><br /></td></tr>
<tr class="separator:ga5aab70691132af097f69a6fca720d1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ab2ccb718e8a88847a9b48a1cf1a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga72ab2ccb718e8a88847a9b48a1cf1a60">mux_query_user_name</a> (<a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle, const char **user_name)</td></tr>
<tr class="memdesc:ga72ab2ccb718e8a88847a9b48a1cf1a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is query the user's name.  <a href="#ga72ab2ccb718e8a88847a9b48a1cf1a60">More...</a><br /></td></tr>
<tr class="separator:ga72ab2ccb718e8a88847a9b48a1cf1a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab01887725cd04ffb81e36a815dc8685d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gab01887725cd04ffb81e36a815dc8685d">mux_query_user_handle</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, const char *user_name, <a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> *p_handle)</td></tr>
<tr class="memdesc:gab01887725cd04ffb81e36a815dc8685d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is query the user's handle.  <a href="#gab01887725cd04ffb81e36a815dc8685d">More...</a><br /></td></tr>
<tr class="separator:gab01887725cd04ffb81e36a815dc8685d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd575e3bc78634d2588a05ea6a0bb72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gacbd575e3bc78634d2588a05ea6a0bb72">mux_query_port_user_number</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, uint32_t *user_count)</td></tr>
<tr class="memdesc:gacbd575e3bc78634d2588a05ea6a0bb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function queries how many users are on the specified port.  <a href="#gacbd575e3bc78634d2588a05ea6a0bb72">More...</a><br /></td></tr>
<tr class="separator:gacbd575e3bc78634d2588a05ea6a0bb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dae1a139a56b4bb7b62e9a916fc8cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga4dae1a139a56b4bb7b62e9a916fc8cff">mux_query_port_user_name</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, <a class="el" href="structmux__port__assign__t.html">mux_port_assign_t</a> *user_name)</td></tr>
<tr class="memdesc:ga4dae1a139a56b4bb7b62e9a916fc8cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function queries user specified port name list.  <a href="#ga4dae1a139a56b4bb7b62e9a916fc8cff">More...</a><br /></td></tr>
<tr class="separator:ga4dae1a139a56b4bb7b62e9a916fc8cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d5fd6803eeb99dd52d990cd7c7748f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga48d5fd6803eeb99dd52d990cd7c7748f">mux_tx</a> (<a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> handle, const <a class="el" href="structmux__buffer__t.html">mux_buffer_t</a> buffers[], uint32_t buffers_counter, uint32_t *send_done_data_len)</td></tr>
<tr class="memdesc:ga48d5fd6803eeb99dd52d990cd7c7748f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mux send data.  <a href="#ga48d5fd6803eeb99dd52d990cd7c7748f">More...</a><br /></td></tr>
<tr class="separator:ga48d5fd6803eeb99dd52d990cd7c7748f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ab592e45c233a65e14a428c467cf98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gab6ab592e45c233a65e14a428c467cf98">mux_control</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, <a class="el" href="group__mux__struct.html#ga7c4c5119e43077164075f241cdbc1aa3">mux_ctrl_cmd_t</a> command, <a class="el" href="unionmux__ctrl__para__t.html">mux_ctrl_para_t</a> *para)</td></tr>
<tr class="memdesc:gab6ab592e45c233a65e14a428c467cf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is mux control operate.  <a href="#gab6ab592e45c233a65e14a428c467cf98">More...</a><br /></td></tr>
<tr class="separator:gab6ab592e45c233a65e14a428c467cf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c1ceff149c0869c1a55cca75f0bb8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga97c1ceff149c0869c1a55cca75f0bb8a">mux_open_save_to_nvdm</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, const char *user_name)</td></tr>
<tr class="memdesc:ga97c1ceff149c0869c1a55cca75f0bb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function saves the user's port information to NVDM.  <a href="#ga97c1ceff149c0869c1a55cca75f0bb8a">More...</a><br /></td></tr>
<tr class="separator:ga97c1ceff149c0869c1a55cca75f0bb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96848a9fcc7b346fb9d2dbd2f6d50c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gab96848a9fcc7b346fb9d2dbd2f6d50c3">mux_close_delete_from_nvdm</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, const char *user_name)</td></tr>
<tr class="memdesc:gab96848a9fcc7b346fb9d2dbd2f6d50c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes the user's port information from NVDM.  <a href="#gab96848a9fcc7b346fb9d2dbd2f6d50c3">More...</a><br /></td></tr>
<tr class="separator:gab96848a9fcc7b346fb9d2dbd2f6d50c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c22327683324a74928be3b2119aabb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga86c22327683324a74928be3b2119aabb">mux_query_port_setting_from_nvdm</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, <a class="el" href="structmux__port__setting__t.html">mux_port_setting_t</a> *setting)</td></tr>
<tr class="memdesc:ga86c22327683324a74928be3b2119aabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the port setting from NVDM.  <a href="#ga86c22327683324a74928be3b2119aabb">More...</a><br /></td></tr>
<tr class="separator:ga86c22327683324a74928be3b2119aabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432d4a2af6da3521e30c213e23dba123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga432d4a2af6da3521e30c213e23dba123">mux_save_port_setting_to_nvdm</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, <a class="el" href="structmux__port__setting__t.html">mux_port_setting_t</a> *setting)</td></tr>
<tr class="memdesc:ga432d4a2af6da3521e30c213e23dba123"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function save the port setting to NVDM.  <a href="#ga432d4a2af6da3521e30c213e23dba123">More...</a><br /></td></tr>
<tr class="separator:ga432d4a2af6da3521e30c213e23dba123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd6c25b1d579efbd75de281a700823f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga8bd6c25b1d579efbd75de281a700823f">mux_query_port_user_number_form_nvdm</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, uint32_t *user_count)</td></tr>
<tr class="memdesc:ga8bd6c25b1d579efbd75de281a700823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function queries how many users are on the specified port from NVDM.  <a href="#ga8bd6c25b1d579efbd75de281a700823f">More...</a><br /></td></tr>
<tr class="separator:ga8bd6c25b1d579efbd75de281a700823f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d216faa8d562ab13bf64c29a1defea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga0d216faa8d562ab13bf64c29a1defea9">mux_query_port_user_name_from_nvdm</a> (<a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a> port, <a class="el" href="structmux__port__assign__t.html">mux_port_assign_t</a> *user_name)</td></tr>
<tr class="memdesc:ga0d216faa8d562ab13bf64c29a1defea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function queries user specified port name list from NVDM.  <a href="#ga0d216faa8d562ab13bf64c29a1defea9">More...</a><br /></td></tr>
<tr class="separator:ga0d216faa8d562ab13bf64c29a1defea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7dc93a8cf6b28901fb572deb838e022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#gab7dc93a8cf6b28901fb572deb838e022">mux_query_user_port_numbers_from_nvdm</a> (const char *user_name, uint32_t *port_count)</td></tr>
<tr class="memdesc:gab7dc93a8cf6b28901fb572deb838e022"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function queries how many ports the user had opened from NVDM.  <a href="#gab7dc93a8cf6b28901fb572deb838e022">More...</a><br /></td></tr>
<tr class="separator:gab7dc93a8cf6b28901fb572deb838e022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a132be0e40aaa0ee999c2062370e965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_u_x.html#ga1a132be0e40aaa0ee999c2062370e965">mux_query_port_numbers_from_nvdm</a> (const char *user_name, <a class="el" href="structmux__port__buffer__t.html">mux_port_buffer_t</a> *port)</td></tr>
<tr class="memdesc:ga1a132be0e40aaa0ee999c2062370e965"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function query the used port index by the user from NVDM.  <a href="#ga1a132be0e40aaa0ee999c2062370e965">More...</a><br /></td></tr>
<tr class="separator:ga1a132be0e40aaa0ee999c2062370e965"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__mux__enum"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mux__enum.html">Enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mux__macro"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mux__macro.html">Macro</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mux__struct"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mux__struct.html">struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabd4b17060da7e6b45627bceda61d7d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mux port close by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>is the user handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX port close success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab96848a9fcc7b346fb9d2dbd2f6d50c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_close_delete_from_nvdm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes the user's port information from NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux user port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_name</td><td>is the user's name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX delete user port success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab6ab592e45c233a65e14a428c467cf98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7c4c5119e43077164075f241cdbc1aa3">mux_ctrl_cmd_t</a>&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionmux__ctrl__para__t.html">mux_ctrl_para_t</a> *&#160;</td>
          <td class="paramname"><em>para</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mux control operate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>is the command want to do. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">para</td><td>is the parameter which want to return from mux_control. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX operate success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab2b5602fbc1fc88e0fe4aa7859fe63ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mux port deinitialize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX port deinitialize success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fae99a7203d897ca65791172d5476ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_exception_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is logging port exception initialize, special for mux port as logging port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>is the mux logging user handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX logging port exception initialize success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga62c07f1835ce9f510fcc853f61d7c131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_exception_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmux__buffer__t.html">mux_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffers_counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is logging port send exception data, special for mux port as logging port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>is the mux logging user handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>is buffer list want to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers_counter</td><td>is buffer count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX exception send data success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5a6637a907492337e5ba1584e8566ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__port__setting__t.html">mux_port_setting_t</a> *&#160;</td>
          <td class="paramname"><em>setting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__protocol__t.html">mux_protocol_t</a> *&#160;</td>
          <td class="paramname"><em>protocol_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mux port initialize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setting</td><td>is mux port setting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_callback</td><td>is protocol callback function when mux to do send and receive data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX port initialize success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab06ec73160c0f545d2c54db34cb48b2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> *&#160;</td>
          <td class="paramname"><em>p_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga12d58527190c649788f79955e5d475d3">mux_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mux port open by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_name</td><td>is the user name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_handle</td><td>is handle, user can get the handle by mux_open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>is the callback function for ready to read and read to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>the user data, as a parameter of callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX port open success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga97c1ceff149c0869c1a55cca75f0bb8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_open_save_to_nvdm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function saves the user's port information to NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux user port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_name</td><td>is the user's name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX save user port success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a132be0e40aaa0ee999c2062370e965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_port_numbers_from_nvdm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__port__buffer__t.html">mux_port_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function query the used port index by the user from NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_name</td><td>is the user's name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port</td><td>is a point, it returns the used ports index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX query parameter success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga86c22327683324a74928be3b2119aabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_port_setting_from_nvdm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__port__setting__t.html">mux_port_setting_t</a> *&#160;</td>
          <td class="paramname"><em>setting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the port setting from NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux user port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">setting</td><td>is the port's configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX query port setting success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dae1a139a56b4bb7b62e9a916fc8cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_port_user_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__port__assign__t.html">mux_port_assign_t</a> *&#160;</td>
          <td class="paramname"><em>user_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function queries user specified port name list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the user specified port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_name</td><td>is the port users name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX query parameter success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d216faa8d562ab13bf64c29a1defea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_port_user_name_from_nvdm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__port__assign__t.html">mux_port_assign_t</a> *&#160;</td>
          <td class="paramname"><em>user_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function queries user specified port name list from NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the user specified port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_name</td><td>is the port users name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX query parameter success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gacbd575e3bc78634d2588a05ea6a0bb72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_port_user_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>user_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function queries how many users are on the specified port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the specified port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_count</td><td>is the user quantity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX query parameter success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bd6c25b1d579efbd75de281a700823f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_port_user_number_form_nvdm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>user_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function queries how many users are on the specified port from NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the specified port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_count</td><td>is the user quantity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX query parameter success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab01887725cd04ffb81e36a815dc8685d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_user_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a> *&#160;</td>
          <td class="paramname"><em>p_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is query the user's handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_name</td><td>is the user's user_name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_handle</td><td>is the user's handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, Query user handle success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga72ab2ccb718e8a88847a9b48a1cf1a60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_user_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>user_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is query the user's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>is the mux user handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_name</td><td>is the user's name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, Query user name success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab7dc93a8cf6b28901fb572deb838e022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_query_user_port_numbers_from_nvdm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function queries how many ports the user had opened from NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_name</td><td>is the user's name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_count</td><td>is the used port quantity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX query parameter success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5aab70691132af097f69a6fca720d1e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__buffer__t.html">mux_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>receive_done_data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mux receive data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>is the mux user handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>is receive buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">receive_done_data_len</td><td>is how many data received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX receive data success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga432d4a2af6da3521e30c213e23dba123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_save_port_setting_to_nvdm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__enum.html#gae1b0dd20d4db55a9ff0dc55ce93f6327">mux_port_t</a>&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmux__port__setting__t.html">mux_port_setting_t</a> *&#160;</td>
          <td class="paramname"><em>setting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function save the port setting to NVDM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>is the mux user port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setting</td><td>is the port's configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX save port setting success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga48d5fd6803eeb99dd52d990cd7c7748f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mux__enum.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> mux_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mux__struct.html#ga7fbf32b0a859295ff9d2d7a8dbd9a62e">mux_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmux__buffer__t.html">mux_buffer_t</a>&#160;</td>
          <td class="paramname"><em>buffers</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffers_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>send_done_data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is mux send data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>is the mux user handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers[]</td><td>is send buffer list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers_counter</td><td>is the count of buffer list which want to send. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">send_done_data_len</td><td>is how many data sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MUX_STATUS_OK, MUX send success. <div class="fragment"></div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 28 2023 17:13:33 for AB158x Series MCU API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
